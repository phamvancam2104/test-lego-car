// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync_LegoCarComponents_Modules_Front_FrontControlComponent_BODY

/************************************************************
              FrontControlComponent class body
 ************************************************************/


// include associated header file
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Front/FrontControlComponent.h"

// Derived includes directives
#include "CarFactoryLibrary/CommunicationInterfaces/IRoboticArmFloatMotor.h"
#include "CarFactoryLibrary/events/CheckRack.h"
#include "CarFactoryLibrary/events/DeliveredCarConveyor.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "EV3PapyrusLibrary/Interfaces/Actuators/ILargeMotor.h"
#include "LegoCarFactoryRefactoringForSync/signals/PrepareConveyor.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"

// Include from Include declaration (body)
void bindPorts(Port& p1, Port& p2) {
}
// End of Include declaration (body)

namespace LegoCarFactoryRefactoringForSync {
namespace LegoCarComponents {
namespace Modules {
namespace Front {

// static attributes (if any)

/**
 * 
 */
void FrontControlComponent::reset() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement
	robotic_arm.float_motors();
	conveyor.motor.stop(false);
	press.motor.stop(false);
	Events::StopProcess s;
	s.is_emergency_stop = true;
	shelf.sendStopProcess(s);
	robotic_arm.sendStopProcess(s);
	conveyor.sendStopProcess(s);
	press.sendStopProcess(s);
	
	Events::RestartAfterEmergencyStop s1;
	shelf.sendRestartAfterEmergencyStop(s1);
	robotic_arm.sendRestartAfterEmergencyStop(s1);
	conveyor.sendRestartAfterEmergencyStop(s1);
	press.sendRestartAfterEmergencyStop(s1);
	
	status = RESULT_READY;
}

/**
 * Initialize all bluetooth connection and ping bricks to check
 * @return ret 
 */
 bool FrontControlComponent::init_bluetooth_communication() {
	cout << "init " << endl;
		if (!ev3Brick.bluetoothDevice.accept_connection(bluetooth_name[MASTER_MODULE])) {
			perror("not connected");
			return false;
		}
		write(MASTER_MODULE, RESULT_OK);	
		cout << "return true " << endl;
		return true;
}

/**
 * answer to a ping command
 */
void FrontControlComponent::ping_response() {
	write(MASTER_MODULE, BluetoothSlaveEnum::RESULT_OK);
}

/**
 * answer to CMD_GET_STATUS
 */
void FrontControlComponent::get_status_response() {
	write(MASTER_MODULE, status);
}

/**
 * 
 * @param sig 
 */
void FrontControlComponent::effectFromEmnergencyStopStatetoMisplace(::CarFactoryLibrary::events::ErrorDetection& /*in*/ sig) {
	error_detection_is_misplace = sig.is_misplace;
}

/**
 * 
 * @return ret 
 */
 bool FrontControlComponent::() {
	return emergency_button.value(0);
}

/**
 * 
 */
void FrontControlComponent::init() {
	led_status.all_led_on();
	usleep(50000);
	led_status.all_led_off();
	manageOrangeLights();
}

/**
 * 
 */
void FrontControlComponent::doActivityCheck() {
	CHECKPOINT
}

/**
 * 
 */
void FrontControlComponent::sendStopProcessEvent() {
	ev3Brick.soundDevice.tone(100, 100);
	robotic_arm.float_motors();
	conveyor.motor.stop(false);
	press.motor.stop(false);
	Events::StopProcess s;
	s.is_emergency_stop = true;
	shelf.sendStopProcess(s);
	robotic_arm.sendStopProcess(s);
	conveyor.sendStopProcess(s);
	press.sendStopProcess(s);
	status = RESULT_STOP;
}

/**
 * 
 */
void FrontControlComponent::sendStopProcess() {
	if(error_detection_is_misplace){
		showMisplacePartGUI();
	} else{
		showEmptyRackGUI(color);
	}
	Events::StopProcess s;
	s.is_emergency_stop = false;
	shelf.sendStopProcess(s);
	robotic_arm.sendStopProcess(s);
	conveyor.sendStopProcess(s);
}

/**
 * 
 */
void FrontControlComponent::show_stop_GUI() {
	showStopGUI();
}

/**
 * 
 */
void FrontControlComponent::send_restart_event() {
	Events::RestartAfterEmergencyStop s;
	shelf.sendRestartAfterEmergencyStop(s);
	robotic_arm.sendRestartAfterEmergencyStop(s);
	conveyor.sendRestartAfterEmergencyStop(s);
	press.sendRestartAfterEmergencyStop(s);
	status = RESULT_READY;
}

/**
 * 
 */
void FrontControlComponent::read() {
	bool stop = false;
		while (!stop) {
			string tmp_string = readFromMaster();
	
			//split receive message
			int split_index = tmp_string.find("-");
			if (split_index != string::npos) {
				extra_msg = tmp_string.substr(split_index+1);
				msg = parseMasterMessage(tmp_string.substr(0, split_index));
				cout << msg << endl;
			} else {
				msg = parseMasterMessage(tmp_string);
			}
			if (msg == CMD_ASSEMBLE || msg == CMD_DELIVER || msg == CMD_LOAD_CAR) {
				status = RESULT_BUSY;
			}
			if(msg != NO_MASTER_MSG)
				stop = true;
			CHECKPOINT
		}
}

/**
 * 
 */
void FrontControlComponent::ping_response() {
	ping_response();
}

/**
 * 
 */
void FrontControlComponent::get_status_response() {
	get_status_response();
}

/**
 * 
 */
void FrontControlComponent::sendPrepareConveyorEvent() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	Events::PrepareConveyor s;
	conveyor.sendPrepareConveyor(s);
}

/**
 * 
 */
void FrontControlComponent::send_check_racks_event() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement
		manageGreenLights();
		CarFactoryLibrary::events::CheckRack s;
		s.color = static_cast<Colors>(std::stoi(extra_msg));
		color = static_cast<Colors>(std::stoi(extra_msg));
		shelf.sendCheckRack(s);
}

/**
 * 
 */
void FrontControlComponent::rewind() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	conveyor.rewind();
}

/**
 * 
 */
void FrontControlComponent::deliver() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	CarFactoryLibrary::events::DeliveredCarConveyor s;
	conveyor.sendDeliveredCarConveyor(s);
}

/**
 * 
 */
FrontControlComponent::FrontControlComponent(): CarFactoryLibrary::Module("in2", "lego-ev3-color", "lego-ev3-color", "lego-ev3-color", "in4", "in3:i2c88", "outB", "in3:i2c88:sv6", "in3:i2c88:sv7", "in3:i2c88:sv8") {
}



} // of namespace Front
} // of namespace Modules
} // of namespace LegoCarComponents
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
              End of FrontControlComponent class body
 ************************************************************/
