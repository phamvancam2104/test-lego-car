// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync_LegoCarComponents_Modules_Front_FrontControlComponent_BODY

/************************************************************
 FrontControlComponent class body
 ************************************************************/

// include associated header file
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Front/FrontControlComponent.h"

// Derived includes directives
#include "CarFactoryLibrary/events/CheckRack.h"
#include "CarFactoryLibrary/events/DeliveredCarConveyor.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "LegoCarFactoryRefactoringForSync/signals/PrepareConveyor.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"

namespace LegoCarFactoryRefactoringForSync {
namespace LegoCarComponents {
namespace Modules {
namespace Front {

// static attributes (if any)

/**
 * 
 */
void FrontControlComponent::reset() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement
	robotic_arm.float_motors();
	conveyor.motor.stop(false);
	press.motor.stop(false);
	Events::StopProcess s;
	s.is_emergency_stop = true;
	shelf.sendStopProcess(s);
	robotic_arm.sendStopProcess(s);
	conveyor.sendStopProcess(s);
	press.sendStopProcess(s);

	Events::RestartAfterEmergencyStop s1;
	shelf.sendRestartAfterEmergencyStop(s1);
	robotic_arm.sendRestartAfterEmergencyStop(s1);
	conveyor.sendRestartAfterEmergencyStop(s1);
	press.sendRestartAfterEmergencyStop(s1);

	status = RESULT_READY;
}

/**
 * Initialize all bluetooth connection and ping bricks to check
 * @return ret 
 */
bool FrontControlComponent::init_bluetooth_communication() {
	cout << "init " << endl;
	if (!ev3Brick.bluetoothDevice.accept_connection(
			bluetooth_name[MASTER_MODULE])) {
		perror("not connected");
		return false;
	}
	write(MASTER_MODULE, RESULT_OK);
	cout << "return true " << endl;
	return true;
}

/**
 * answer to a ping command
 */
void FrontControlComponent::ping_response() {
	write(MASTER_MODULE, BluetoothSlaveEnum::RESULT_OK);
}

/**
 * answer to CMD_GET_STATUS
 */
void FrontControlComponent::get_status_response() {
	write(MASTER_MODULE, status);
}

/**
 * 
 * @param sig 
 */
void FrontControlComponent::effectFromEmnergencyStopStatetoMisplace(
		::CarFactoryLibrary::events::ErrorDetection& /*in*/sig) {
	error_detection_is_misplace = sig.is_misplace;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromWaittoEmergencyButtonPressGuard() {
	return emergency_button.value(0);
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoice1toRestartGuard() {
	return ev3Brick.topButton.pressed();
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoice2toRestartGuard() {
	return ev3Brick.topButton.pressed();
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoPingGuard() {
	return msg == CarFactoryLibrary::CMD_PING;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoGetStatusGuard() {
	return msg == CarFactoryLibrary::CMD_GET_STATUS;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoLoadCarGuard() {
	return msg == CarFactoryLibrary::CMD_LOAD_CAR;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoDeliverGuard() {
	return msg == CarFactoryLibrary::CMD_DELIVER;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoRewindGuard() {
	return msg == CarFactoryLibrary::CMD_REWIND;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoAssembleGuard() {
	return msg == CarFactoryLibrary::CMD_ASSEMBLE;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoFinalState1Guard() {
	return msg == CarFactoryLibrary::CMD_STOP;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromChoicetoResetGuard() {
	return msg == CarFactoryLibrary::CMD_RESET;
}

/**
 * 
 * @return ret 
 */
bool FrontControlComponent::fromInitializationtoPrincipalStateGuard() {
	return init_bluetooth_communication();
}

/**
 * 
 */
void FrontControlComponent::init() {
	led_status.all_led_on();
	usleep(50000);
	led_status.all_led_off();
	manageOrangeLights();
}

/**
 * 
 */
void FrontControlComponent::doActivityCheck() {
	CHECKPOINT
}

/**
 * 
 */
void FrontControlComponent::sendStopProcessEvent() {
	ev3Brick.soundDevice.tone(100, 100);
	robotic_arm.float_motors();
	conveyor.motor.stop(false);
	press.motor.stop(false);
	Events::StopProcess s;
	s.is_emergency_stop = true;
	shelf.sendStopProcess(s);
	robotic_arm.sendStopProcess(s);
	conveyor.sendStopProcess(s);
	press.sendStopProcess(s);
	status = RESULT_STOP;
}

/**
 * 
 */
void FrontControlComponent::sendStopProcess() {
	if (error_detection_is_misplace) {
		showMisplacePartGUI();
	} else {
		showEmptyRackGUI (color);
	}
	Events::StopProcess s;
	s.is_emergency_stop = false;
	shelf.sendStopProcess(s);
	robotic_arm.sendStopProcess(s);
	conveyor.sendStopProcess(s);
}

/**
 * 
 */
void FrontControlComponent::show_stop_GUI() {
	showStopGUI();
}

/**
 * 
 */
void FrontControlComponent::send_restart_event() {
	Events::RestartAfterEmergencyStop s;
	shelf.sendRestartAfterEmergencyStop(s);
	robotic_arm.sendRestartAfterEmergencyStop(s);
	conveyor.sendRestartAfterEmergencyStop(s);
	press.sendRestartAfterEmergencyStop(s);
	status = RESULT_READY;
}

/**
 * 
 */
void FrontControlComponent::read() {
	bool stop = false;
	while (!stop) {
		string tmp_string = readFromMaster();

		//split receive message
		int split_index = tmp_string.find("-");
		if (split_index != string::npos) {
			extra_msg = tmp_string.substr(split_index + 1);
			msg = parseMasterMessage(tmp_string.substr(0, split_index));
			cout << msg << endl;
		} else {
			msg = parseMasterMessage(tmp_string);
		}
		if (msg == CMD_ASSEMBLE || msg == CMD_DELIVER || msg == CMD_LOAD_CAR) {
			status = RESULT_BUSY;
		}
		if (msg != NO_MASTER_MSG)
			stop = true;
		CHECKPOINT
	}
}

/**
 * 
 */
void FrontControlComponent::ping_response() {
	ping_response();
}

/**
 * 
 */
void FrontControlComponent::get_status_response() {
	get_status_response();
}

/**
 * 
 */
void FrontControlComponent::sendPrepareConveyorEvent() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	Events::PrepareConveyor s;
	conveyor.sendPrepareConveyor(s);
}

/**
 * 
 */
void FrontControlComponent::send_check_racks_event() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement
	manageGreenLights();
	CarFactoryLibrary::events::CheckRack s;
	s.color = static_cast<Colors>(std::stoi(extra_msg));
	color = static_cast<Colors>(std::stoi(extra_msg));
	shelf.sendCheckRack(s);
}

/**
 * 
 */
void FrontControlComponent::rewind() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	conveyor.rewind();
}

/**
 * 
 */
void FrontControlComponent::deliver() {
	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	CarFactoryLibrary::events::DeliveredCarConveyor s;
	conveyor.sendDeliveredCarConveyor(s);
}

/**
 * 
 */
void FrontControlComponent::FrontControlComponent() const {
}

/**
 * 
 */
FrontControlComponent::FrontControlComponent() :
		frontcontrolcomponentController(this) {
}

} // of namespace Front
} // of namespace Modules
} // of namespace LegoCarComponents
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
 End of FrontControlComponent class body
 ************************************************************/
