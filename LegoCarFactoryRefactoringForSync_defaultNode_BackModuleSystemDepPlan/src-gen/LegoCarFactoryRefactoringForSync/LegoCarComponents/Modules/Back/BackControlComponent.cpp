// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync_LegoCarComponents_Modules_Back_BackControlComponent_BODY

/************************************************************
 BackControlComponent class body
 ************************************************************/

// include associated header file
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Back/BackControlComponent.h"

// Derived includes directives
#include "CarFactoryLibrary/CommunicationInterfaces/IRoboticArmFloatMotor.h"
#include "CarFactoryLibrary/events/CheckRack.h"
#include "CarFactoryLibrary/events/DeliveredCarConveyor.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "EV3PapyrusLibrary/Interfaces/Actuators/ILargeMotor.h"
#include "LegoCarFactoryRefactoringForSync/signals/PrepareConveyor.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"

namespace LegoCarFactoryRefactoringForSync {
namespace LegoCarComponents {
namespace Modules {
namespace Back {

// static attributes (if any)

/**
 * 
 */
void BackControlComponent::send_check_racks_event() {

	write(MASTER_MODULE, RESULT_OK); //acknowledgement
	manageGreenLights();
	CarFactoryLibrary::events::CheckRack s;
	s.color = static_cast<Colors>(std::stoi(extra_msg));
	color = static_cast<Colors>(std::stoi(extra_msg));
	pOutCheckRack.outIntf->push(s); //shelf.sendCheckRack(s);
}

/**
 * Initialize all bluetooth connection and ping bricks to check
 * @return ret 
 */
bool BackControlComponent::init_bluetooth_communication() {

	cout << "init " << endl;
	if (!ev3Brick.bluetoothDevice.accept_connection(
			bluetooth_name[MASTER_MODULE])) {
		perror("not connected");
		return false;
	}
	write(MASTER_MODULE, RESULT_OK);
	cout << "return true " << endl;
	return true;
}

/**
 * Constructor of the BackModule
 */
BackControlComponent::BackControlComponent() :
		Module("in2", "lego-ev3-color", "lego-ev3-color", "lego-ev3-color",
				"in4", "in3:i2c88", "outB", "in3:i2c88:sv6", "in3:i2c88:sv7",
				"in3:i2c88:sv8"), backcontrolcomponentController(this) {
}

/**
 * 
 * @param sig 
 */
void BackControlComponent::effectFromEmnergencyStopStatetoMisplace(
		::CarFactoryLibrary::events::ErrorDetection& /*in*/sig) {

	error_detection_is_misplace = sig.is_misplace;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromWaittoEmergencyButtonPressGuard() {

	return emergency_button.value(0);
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoice2toRestartGuard() {

	return ev3Brick.topButton.pressed();
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoice1toRestartGuard() {

	return ev3Brick.topButton.pressed();
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoPingGuard() {

	return msg == CMD_PING;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoGetStatusGuard() {

	return msg == CMD_GET_STATUS;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoLoadCarGuard() {

	return msg == CMD_LOAD_CAR;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoDeliverGuard() {

	return msg == CMD_DELIVER;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoRewindGuard() {

	return msg == CMD_REWIND;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoAssembleGuard() {

	return msg == CMD_ASSEMBLE;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoResetGuard() {

	return msg == CMD_RESET;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromChoicetoFinalState1Guard() {

	return msg == CMD_STOP;
}

/**
 * 
 * @return ret 
 */
bool BackControlComponent::fromInitializationtoPrincipalStateGuard() {

	return init_bluetooth_communication();
}

/**
 * 
 */
void BackControlComponent::init() {

	led_status.all_led_on();
	usleep(50000);
	led_status.all_led_off();
	manageOrangeLights();
}

/**
 * 
 */
void BackControlComponent::doActivityCheck() {

	//CHECKPOINT
}

/**
 * 
 */
void BackControlComponent::sendStopProcessEvent() {

	ev3Brick.soundDevice.tone(100, 100);
	pFloatMotor.requiredIntf->float_motors(); //robotic_arm.float_motors();
	pLargeMotorConvoyer.requiredIntf->stop(); //conveyor.motor.stop(false);
	pLargeMotorPress.requiredIntf->stop(); //press.motor.stop(false);
	LegoCarFactoryRefactoringForSync::signals::StopProcess s;
	s.is_emergency_stop = true;
	pOutStopProcess_Shelf.outIntf->push(s); //shelf.sendStopProcess(s);
	pOutStopProcess_RoboticArm.outIntf->push(s); //robotic_arm.sendStopProcess(s);
	pStopProcess_Convoyer.outIntf->push(s); //conveyor.sendStopProcess(s);
	pOutStopProcess_Press.outIntf->push(s); //press.sendStopProcess(s);
	status = RESULT_STOP;
}

/**
 * 
 */
void BackControlComponent::sendStopProcess() {

	if (error_detection_is_misplace) {
		showMisplacePartGUI();
	} else {
		showEmptyRackGUI (color);
	}
	LegoCarFactoryRefactoringForSync::signals::StopProcess s;
	s.is_emergency_stop = false;
	pOutStopProcess_Shelf.outIntf->push(s); //shelf.sendStopProcess(s);
	pOutStopProcess_RoboticArm.outIntf->push(s); //robotic_arm.sendStopProcess(s);
	pStopProcess_Convoyer.outIntf->push(s); //conveyor.sendStopProcess(s);
}

/**
 * 
 */
void BackControlComponent::send_restart_event() {

	LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop s;
	pOutRestart_Shelf.outIntf->push(s); //shelf.sendRestartAfterEmergencyStop(s);
	pOutRestart_Robotic.outIntf->push(s); //robotic_arm.sendRestartAfterEmergencyStop(s);
	pOutRestart_Convoyer.outIntf->push(s); //conveyor.sendRestartAfterEmergencyStop(s);
	pOutRestart_Press.outIntf->push(s); //press.sendRestartAfterEmergencyStop(s);
	status = RESULT_READY;
}

/**
 * 
 */
void BackControlComponent::show_stop_GUI() {

	showStopGUI();
}

/**
 * 
 */
void BackControlComponent::read() {

	bool stop = false;
	while (!stop) {
		string tmp_string = readFromMaster();

		//split receive message
		int split_index = tmp_string.find("-");
		if (split_index != string::npos) {
			extra_msg = tmp_string.substr(split_index + 1);
			msg = parseMasterMessage(tmp_string.substr(0, split_index));
			cout << msg << endl;
		} else {
			msg = parseMasterMessage(tmp_string);
		}
		if (msg == CMD_ASSEMBLE || msg == CMD_DELIVER || msg == CMD_LOAD_CAR) {
			status = RESULT_BUSY;
		}
		if (msg != NO_MASTER_MSG)
			stop = true;
		//CHECKPOINT
	}
}

/**
 * 
 */
void BackControlComponent::reset() {

	write(MASTER_MODULE, RESULT_OK); //acknowledgement
	pFloatMotor.requiredIntf->float_motors(); //robotic_arm.float_motors();
	pLargeMotorConvoyer.requiredIntf->stop(); //conveyor.motor.stop(false);
	pLargeMotorPress.requiredIntf->stop(); //press.motor.stop(false);
	LegoCarFactoryRefactoringForSync::signals::StopProcess s;
	s.is_emergency_stop = true;
	pOutStopProcess_Shelf.outIntf->push(s); //shelf.sendStopProcess(s);
	pOutStopProcess_RoboticArm.outIntf->push(s); //robotic_arm.sendStopProcess(s);
	pStopProcess_Convoyer.outIntf->push(s); //conveyor.sendStopProcess(s);
	pOutStopProcess_Press.outIntf->push(s); //press.sendStopProcess(s);

	LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop s1;
	pOutRestart_Shelf.outIntf->push(s1); //shelf.sendRestartAfterEmergencyStop(s1);
	pOutRestart_Robotic.outIntf->push(s1); //robotic_arm.sendRestartAfterEmergencyStop(s1);
	pOutRestart_Convoyer.outIntf->push(s1); //conveyor.sendRestartAfterEmergencyStop(s1);
	pOutRestart_Press.outIntf->push(s1); //press.sendRestartAfterEmergencyStop(s1);

	status = RESULT_READY;
}

/**
 * 
 */
void BackControlComponent::ping_response() {

	ping_response();
}

/**
 * 
 */
void BackControlComponent::get_status_response() {

	get_status_response();
}

/**
 * 
 */
void BackControlComponent::sendPrepareConveyorEvent() {

	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	LegoCarFactoryRefactoringForSync::signals::PrepareConveyor s;
	pPrepare.outIntf->push(s); //conveyor.sendPrepareConveyor(s);
}

/**
 * 
 */
void BackControlComponent::deliver() {

	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	CarFactoryLibrary::events::DeliveredCarConveyor s;
	pOutDelivered.outIntf->push(s); //conveyor.sendDeliveredCarConveyor(s);
}

/**
 * 
 */
void BackControlComponent::rewind() {

	write(MASTER_MODULE, RESULT_OK); //acknowledgement	
	manageGreenLights();
	//TODO:conveyor.rewind();
}

} // of namespace Back
} // of namespace Modules
} // of namespace LegoCarComponents
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
 End of BackControlComponent class body
 ************************************************************/
