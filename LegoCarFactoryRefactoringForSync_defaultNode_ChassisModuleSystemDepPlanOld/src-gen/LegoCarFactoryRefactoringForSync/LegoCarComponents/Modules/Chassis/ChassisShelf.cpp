// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync_LegoCarComponents_Modules_Chassis_ChassisShelf_BODY

/************************************************************
 ChassisShelf class body
 ************************************************************/

// include associated header file
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Chassis/ChassisShelf.h"

// Derived includes directives
#include "CarFactoryLibrary/events/CheckRack.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "CarFactoryLibrary/events/RoboticArmPickPiece.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"

namespace LegoCarFactoryRefactoringForSync {
namespace LegoCarComponents {
namespace Modules {
namespace Chassis {

// static attributes (if any)

/**
 * 
 * @return ret 
 */
bool ChassisShelf::fromChoicetoEmpty_rackGuard() {

	return get_status() == CarFactoryLibrary::RESULT_ERROR;
}

/**
 * get the current module
 * @return ret 
 */
int ChassisShelf::get_current_module() {

	return static_cast<CarFactoryLibrary::Shelf*>(this)->pModule.requiredIntf->getCurrentModule();
}

/**
 * send the RoboticArmPickPeice event
 */
void ChassisShelf::send_robotic_arm_pick_piece_event() {

	CarFactoryLibrary::events::RoboticArmPickPiece s;
	pPickPiece.outIntf->push(s);
}

/**
 * send the StopProcess event
 */
void ChassisShelf::send_stop_process_event() {

	LegoCarFactoryRefactoringForSync::signals::StopProcess s;
	s.is_emergency_stop = true;
	pInStopProcess.outIntf->push(s);
}

/**
 * 
 */
ChassisShelf::ChassisShelf() :
		::CarFactoryLibrary::Shelf(2, "in2:i2c82:mux3", "in2:i2c81:mux2"), chassisshelfController(
				this) {
}

/**
 * 
 * @return ret 
 */
::CarFactoryLibrary::BluetoothSlaveEnum ChassisShelf::get_status() {

	return static_cast<CarFactoryLibrary::Shelf*>(this)->pModule.requiredIntf->getStatus();
}

/**
 * 
 * @return ret 
 */
bool ChassisShelf::fromTesttoNot_Master_ModuleGuard() {

	return get_current_module() != CarFactoryLibrary::MASTER_MODULE;
}

/**
 * 
 * @return ret 
 */
bool ChassisShelf::fromWhich_racktoFirst_rackGuard() {

	return !is_empty(1);
}

/**
 * 
 * @return ret 
 */
bool ChassisShelf::fromWhich_racktoSecond_rackGuard() {

	return !is_empty(2);
}

/**
 * 
 * @return ret 
 */
bool ChassisShelf::fromChoicetoWait_endGuard() {

	return get_status() == CarFactoryLibrary::RESULT_READY;
}

/**
 * 
 * @param status 
 */
void ChassisShelf::set_status(BluetoothSlaveEnum /*in*/status) {
}

// opaque behavior without specification (typically from state machine)
/**
 * 
 * 
 */
void ChassisShelf::get_status() {
	return get_module()->status;
}
// opaque behavior without specification (typically from state machine)
/**
 * 
 * 
 */
void ChassisShelf::set_status() {
	get_module()->status = status;
}
// opaque behavior without specification (typically from state machine)
/**
 * 
 * 
 */
void ChassisShelf::get_status() {

	return static_cast<CarFactoryLibrary::Shelf*>(this)->pModule.requiredIntf->getStatus();
}
// opaque behavior without specification (typically from state machine)
/**
 * 
 * 
 */
void ChassisShelf::get_status() {

	return static_cast<CarFactoryLibrary::Shelf*>(this)->pModule.requiredIntf->getStatus();
}

} // of namespace Chassis
} // of namespace Modules
} // of namespace LegoCarComponents
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
 End of ChassisShelf class body
 ************************************************************/
