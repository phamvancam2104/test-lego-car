// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync_LegoCarComponents_Modules_Chassis_ChassisConvoyer_BODY

/************************************************************
              ChassisConvoyer class body
 ************************************************************/


// include associated header file
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Chassis/ChassisConvoyer.h"

// Derived includes directives
#include "CarFactoryLibrary/events/CheckRack.h"
#include "CarFactoryLibrary/events/DeliveredCarConveyor.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "LegoCarFactoryRefactoringForSync/signals/PrepareConveyor.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"


namespace LegoCarFactoryRefactoringForSync {
namespace LegoCarComponents {
namespace Modules {
namespace Chassis {

// static attributes (if any)

/**
 * 
 * @return ret 
 */
 bool ChassisConvoyer::fromChoicetoMisplaceGuard() {
	return get_status() == CarFactoryLibrary::RESULT_ERROR;
}

/**
 * check the presence of the chassis on the conveyor (check the sequence : white - unknown color - white)
 * @return ret 
 */
 bool ChassisConvoyer::check_presence() {
	color_sensor.set_mode("COL-COLOR");
		 int color_state = 0;
		 bool ret = false;
		 //check white - black - white sequence
		 while(motor.speed() == 0);
		 while (motor.speed() != 0) {
		 char color = color_sensor.value(0);
		 if (color == 6 && color_state==0) { //first white wheel
		 color_state++;
		 }
		 if (color == 0 && color_state==1) { //none after white wheel
		 color_state++;
		 }
		 if (color == 6 && color_state==2) { //detect second white whell
		 color_state++;
		 ret = true;
		 }
		 }
		 
		 return ret;
}

/**
 * check the presence of the chassis on the conveyor (check the sequence : white - unknown color - white)
 * @return ret 
 */
 int ChassisConvoyer::get_current_module() {
	return ((CarFactoryLibrary::Conveyor*)this)->pModule.requiredIntf->getCurrentModule();
}

/**
 * check the presence of the chassis on the conveyor (check the sequence : white - unknown color - white)
 */
void ChassisConvoyer::send_stop_process_event() {
	LegoCarFactoryRefactoringForSync::signals::StopProcess s;
		s.is_emergency_stop = true;
		pStopProcess.outIntf->push(s);
}

/**
 * 
 */
ChassisConvoyer::ChassisConvoyer(): ::CarFactoryLibrary::Conveyor("outC", "in2:i2c80:mux1") {
}

/**
 * 
 * @return ret 
 */
 ::CarFactoryLibrary::BluetoothSlaveEnum ChassisConvoyer::get_status() {
	return CarFactoryLibrary::NO_SLAVE_MSG;
}

/**
 * 
 * @param status 
 */
void ChassisConvoyer::set_status(::CarFactoryLibrary::BluetoothSlaveEnum /*in*/ status) {
	static_cast<CarFactoryLibrary::Convoyer*>(this)->pModule.requiredIntf->setStatus(status);
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer::reset_first_time(::LegoCarFactoryRefactoringForSync::signals::StopProcess& /*in*/ sig) {
	if(sig.is_emergency_stop)
		first_time = true;
}

/**
 * 
 */
void ChassisConvoyer::effectFromChoicetoRestart() {
	first_time = true;
		send_stop_process_event();
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer::save_color(::LegoCarFactoryRefactoringForSync::signals::PrepareConveyor& /*in*/ sig) {
	color = sig.color;
}

/**
 * 
 * @return ret 
 */
 bool ChassisConvoyer::fromChoice1toReplaceGuard() {
	return get_current_module() == CarFactoryLibrary::MASTER_MODULE;
}

/**
 * 
 * @return ret 
 */
 bool ChassisConvoyer::fromChoice0toGo_wait_positionGuard() {
	return get_current_module() == CarFactoryLibrary::MASTER_MODULE;
}

/**
 * 
 * @return ret 
 */
 bool ChassisConvoyer::fromChoice2toMisplaceGuard() {
	return is_misplace;
}

/**
 * 
 * @return ret 
 */
 bool ChassisConvoyer::fromChoice3toGo_wait_positionGuard() {
	return get_status() == CarFactoryLibrary::RESULT_READY;
}

/**
 * 
 * @return ret 
 */
 bool ChassisConvoyer::fromChoicetoSendEndOfModuleEventGuard() {
	return get_status() == CarFactoryLibrary::RESULT_READY;
}



} // of namespace Chassis
} // of namespace Modules
} // of namespace LegoCarComponents
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
              End of ChassisConvoyer class body
 ************************************************************/
