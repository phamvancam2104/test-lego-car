// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync___Architecture__Delegatee_Chassis_ChassisConvoyer__Delegatee_BODY

/************************************************************
              ChassisConvoyer__Delegatee class body
 ************************************************************/


// include associated header file
#include "LegoCarFactoryRefactoringForSync/__Architecture__Delegatee/Chassis/ChassisConvoyer__Delegatee.h"

// Derived includes directives
#include "CarFactoryLibrary/IModule.h"
#include "CarFactoryLibrary/events/CheckRack.h"
#include "CarFactoryLibrary/events/DeliveredCarConveyor.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "EV3PapyrusLibrary/IColorSensor.h"
#include "EV3PapyrusLibrary/Interfaces/Actuators/ILargeMotor.h"
#include "EV3PapyrusLibrary/Interfaces/EV3Brick/ILcd.h"
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Chassis/ChassisConvoyer.h"
#include "LegoCarFactoryRefactoringForSync/signals/PrepareConveyor.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"
#include "statemachine/Pkg_statemachine.h"


namespace LegoCarFactoryRefactoringForSync {
namespace __Architecture__Delegatee {
namespace Chassis {

// static attributes (if any)

/**
 * 
 */
void ChassisConvoyer__Delegatee::dispatchEvent() {
	bool popDeferred = false;
	dispatchFlag = true;
	
	//initialze root active state
	//execute initial effect
	ChassisConveyorStateMachine_Region1_Enter(CHASSISCONVOYER_CHASSISCONVEYORSTATEMACHINE_REGION1_DEFAULT);
	
	while(systemState != statemachine::STOPPED) {
		//run-to-completion: need to have a mutex here
		currentEvent = eventQueue.pop(popDeferred);
		if (currentEvent != NULL) {
			CHASSISCONVOYER__DELEGATEE_GET_CONTROL
			switch(currentEvent->eventID) {
				case DELIVEREDCARCONVEYOR_ID:
					::CarFactoryLibrary::events::DeliveredCarConveyor sig_DELIVEREDCARCONVEYOR_ID;
					memcpy(&sig_DELIVEREDCARCONVEYOR_ID, currentEvent->data, sizeof(::CarFactoryLibrary::events::DeliveredCarConveyor));
					processDeliveredCarConveyor(sig_DELIVEREDCARCONVEYOR_ID);
					break;
				case STOPPROCESS_ID:
					::LegoCarFactoryRefactoringForSync::signals::StopProcess sig_STOPPROCESS_ID;
					memcpy(&sig_STOPPROCESS_ID, currentEvent->data, sizeof(::LegoCarFactoryRefactoringForSync::signals::StopProcess));
					processStopProcess(sig_STOPPROCESS_ID);
					break;
				case RESTARTAFTEREMERGENCYSTOP_ID:
					::LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop sig_RESTARTAFTEREMERGENCYSTOP_ID;
					memcpy(&sig_RESTARTAFTEREMERGENCYSTOP_ID, currentEvent->data, sizeof(::LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop));
					processRestartAfterEmergencyStop(sig_RESTARTAFTEREMERGENCYSTOP_ID);
					break;
				case PREPARECONVEYOR_ID:
					::LegoCarFactoryRefactoringForSync::signals::PrepareConveyor sig_PREPARECONVEYOR_ID;
					memcpy(&sig_PREPARECONVEYOR_ID, currentEvent->data, sizeof(::LegoCarFactoryRefactoringForSync::signals::PrepareConveyor));
					processPrepareConveyor(sig_PREPARECONVEYOR_ID);
					break;
					case COMPLETIONEVENT_ID: 
						processCompletionEvent();
					break;
			}
			if (systemState == statemachine::EVENT_DEFERRED) {
				eventQueue.saveDeferred(*currentEvent);
			}
			popDeferred = (systemState != statemachine::EVENT_DEFERRED);
			systemState = statemachine::IDLE;
			CHASSISCONVOYER__DELEGATEE_RELEASE_CONTROL
		}
	}
}

/**
 * 
 * @param enter_mode 
 */
void ChassisConvoyer__Delegatee::ChassisConveyorStateMachine_Region1_Enter(char /*in*/ enter_mode) {
	switch(enter_mode) {
		case CHASSISCONVOYER_CHASSISCONVEYORSTATEMACHINE_REGION1_DEFAULT:
			activeStateID = PRINCIPALSTATE_ID;
			
			
			PrincipalState_Region1_Enter(CHASSISCONVOYER_PRINCIPALSTATE_REGION1_DEFAULT);
			//TODO: set systemState to EVENT_CONSUMED
			break;
	}
}

/**
 * 
 * @param enter_mode 
 */
void ChassisConvoyer__Delegatee::PrincipalState_Region1_Enter(char /*in*/ enter_mode) {
	switch(enter_mode) {
		case CHASSISCONVOYER_PRINCIPALSTATE_REGION1_DEFAULT:
			states[PRINCIPALSTATE_ID].actives[0] = GO_STOP_POSITION_ID;
			
			
			//TODO: set systemState to EVENT_CONSUMED
			break;
	}
}

/**
 * 
 */
void ChassisConvoyer__Delegatee::PrincipalState_Region1_Exit() {
	//exiting region Region1
	if (states[PRINCIPALSTATE_ID].actives[0] != STATE_MAX) {
		//signal to exit the doActivity of sub-state of PrincipalState
		setFlag(states[PRINCIPALSTATE_ID].actives[0], statemachine::TF_DO_ACTIVITY, false);
		if (GO_STOP_POSITION_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (REPLACE_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (GO_CHECK_PRESENCE_POSITION_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (DELIVER_CAR_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (SENDENDOFMODULEEVENT_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (SENDLOADCARCOMMAND_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (WAITSLAVEISNOTBUSY_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (GO_WAIT_POSITION_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (REWIND_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (SENDDELIVERCOMMAND_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (WAITSLAVEISNOTBUSY2_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		} else 
		if (MISPLACE_ID == states[PRINCIPALSTATE_ID].actives[0]) {
		}
		//exit action of sub-state of PrincipalState
		StateExit(states[PRINCIPALSTATE_ID].actives[0]);
		//set active sub-state of PrincipalState to STATE_MAX meaning NULL
		states[PRINCIPALSTATE_ID].actives[0] = STATE_MAX;
	}
}

/**
 * 
 */
ChassisConvoyer__Delegatee::ChassisConvoyer__Delegatee(): systemState(statemachine::IDLE) {
	//startBehavior();
}

/**
 * 
 */
void ChassisConvoyer__Delegatee::startBehavior() {
	// initialize all threads, the threads wait until the associated flag is set
	for(int i = 0; i < (int) STATE_MAX; i++) {
		if (states[i].hasDoActivity) {
			threadStructs[i].id = i;
			threadStructs[i].ptr = this;
			threadStructs[i].func_type = statemachine::TF_DO_ACTIVITY;
			mutexes[i] = PTHREAD_MUTEX_INITIALIZER;
			conds[i] = PTHREAD_COND_INITIALIZER;
			pthread_create(&threads[i], NULL, &ChassisConvoyer__Delegatee::thread_func_wrapper, &threadStructs[i]);
		}
	}
		
			
			
	
	runToCompletionMutex = PTHREAD_MUTEX_INITIALIZER;
	runToCompletionCond = PTHREAD_COND_INITIALIZER;
	
	dispatchStruct = statemachine::StructForThread_t(this, 0, 0, statemachine::TF_STATE_MACHINE_TYPE, 0);
	ChassisConvoyer__Delegatee_THREAD_CREATE(dispatchThread, dispatchStruct)
}

/**
 * 
 */
ChassisConvoyer__Delegatee::~ChassisConvoyer__Delegatee() {
	stopBehavior();
}

/**
 * 
 */
void ChassisConvoyer__Delegatee::stopBehavior() {
	systemState = statemachine::STOPPED;
		//signal and wait for doActivity termination
		for(int i = 0; i < (int) STATE_MAX; i++) {
			if (states[i].hasDoActivity) {
				pthread_cond_signal(&conds[i]);
				pthread_join(threads[i], NULL);
			}
		}
		
		//signal and wait for time event thread termination
	
		//main thread
		pthread_join(dispatchThread, NULL);
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::processDeliveredCarConveyor(::CarFactoryLibrary::events::DeliveredCarConveyor& /*in*/ sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (states[PRINCIPALSTATE_ID].actives[0] == REWIND_ID) {
		//from Rewind to choice1
		if (true) {
			if (choice1_CompletionEvent == 0) {
				states[PRINCIPALSTATE_ID].actives[0] = REPLACE_ID;
				//starting the counters for time events
				//start activity of replace by calling setFlag
				setFlag(REPLACE_ID, statemachine::TF_DO_ACTIVITY, true);
			} else { 
				states[PRINCIPALSTATE_ID].actives[0] = SENDDELIVERCOMMAND_ID;
				//starting the counters for time events
				//start activity of SendDeliverCommand by calling setFlag
				setFlag(SENDDELIVERCOMMAND_ID, statemachine::TF_DO_ACTIVITY, true);
			}
		systemState = statemachine::EVENT_CONSUMED;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::push(::CarFactoryLibrary::events::DeliveredCarConveyor& /*in*/ sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, DELIVEREDCARCONVEYOR_ID, statemachine::SIGNAL_EVENT, 0, sizeof(::CarFactoryLibrary::events::DeliveredCarConveyor));
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::processStopProcess(::LegoCarFactoryRefactoringForSync::signals::StopProcess& /*in*/ sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch(activeStateID) {
			case PRINCIPALSTATE_ID: 
				//from PrincipalState to Restart
				if (true) {
				PrincipalState_Region1_Exit();
				component->reset_first_time(sig);
				activeStateID = RESTART_ID;
				//starting the counters for time events
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			default:
				//do nothing
				break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::push(::LegoCarFactoryRefactoringForSync::signals::StopProcess& /*in*/ sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, STOPPROCESS_ID, statemachine::SIGNAL_EVENT, 0, sizeof(::LegoCarFactoryRefactoringForSync::signals::StopProcess));
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::processRestartAfterEmergencyStop(::LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop& /*in*/ sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch(activeStateID) {
			case RESTART_ID: 
				//from Restart to PrincipalState
				if (true) {
				activeStateID = PRINCIPALSTATE_ID;
				//starting the counters for time events
				PrincipalState_Region1_Enter(CHASSISCONVOYER_PRINCIPALSTATE_REGION1_DEFAULT);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			default:
				//do nothing
				break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::push(::LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop& /*in*/ sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, RESTARTAFTEREMERGENCYSTOP_ID, statemachine::SIGNAL_EVENT, 0, sizeof(::LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop));
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::processPrepareConveyor(::LegoCarFactoryRefactoringForSync::signals::PrepareConveyor& /*in*/ sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (states[PRINCIPALSTATE_ID].actives[0] == GO_STOP_POSITION_ID) {
		//from go_stop_position to choice0
		if (true) {
			component->save_color(sig);
			if (choice0_CompletionEvent == 0) {
				states[PRINCIPALSTATE_ID].actives[0] = GO_WAIT_POSITION_ID;
				//starting the counters for time events
				//start activity of go_wait_position by calling setFlag
				setFlag(GO_WAIT_POSITION_ID, statemachine::TF_DO_ACTIVITY, true);
			} else { 
				states[PRINCIPALSTATE_ID].actives[0] = SENDLOADCARCOMMAND_ID;
				//starting the counters for time events
				//start activity of SendLoadCarCommand by calling setFlag
				setFlag(SENDLOADCARCOMMAND_ID, statemachine::TF_DO_ACTIVITY, true);
			}
		systemState = statemachine::EVENT_CONSUMED;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisConvoyer__Delegatee::push(::LegoCarFactoryRefactoringForSync::signals::PrepareConveyor& /*in*/ sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, PREPARECONVEYOR_ID, statemachine::SIGNAL_EVENT, 0, sizeof(::LegoCarFactoryRefactoringForSync::signals::PrepareConveyor));
}

/**
 * 
 */
void ChassisConvoyer__Delegatee::processCompletionEvent() {
	systemState = statemachine::EVENT_PROCESSING;
	if (states[PRINCIPALSTATE_ID].actives[0] == MISPLACE_ID && (currentEvent->associatedState == MISPLACE_ID)) {
		//from Misplace to Restart
		if (true) {
		PrincipalState_Region1_Exit();
		activeStateID = RESTART_ID;
		//starting the counters for time events
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == REPLACE_ID && (currentEvent->associatedState == REPLACE_ID)) {
		//from replace to go_check_presence_position
		if (true) {
		states[PRINCIPALSTATE_ID].actives[0] = GO_CHECK_PRESENCE_POSITION_ID;
		//starting the counters for time events
		//start activity of go_check_presence_position by calling setFlag
		setFlag(GO_CHECK_PRESENCE_POSITION_ID, statemachine::TF_DO_ACTIVITY, true);
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == DELIVER_CAR_ID && (currentEvent->associatedState == DELIVER_CAR_ID)) {
		//from Deliver_car to SendEndOfModuleEvent
		if (true) {
		states[PRINCIPALSTATE_ID].actives[0] = SENDENDOFMODULEEVENT_ID;
		//starting the counters for time events
		//start activity of SendEndOfModuleEvent by calling setFlag
		setFlag(SENDENDOFMODULEEVENT_ID, statemachine::TF_DO_ACTIVITY, true);
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == SENDLOADCARCOMMAND_ID && (currentEvent->associatedState == SENDLOADCARCOMMAND_ID)) {
		//from SendLoadCarCommand to WaitSlaveIsNotBusy
		if (true) {
		states[PRINCIPALSTATE_ID].actives[0] = WAITSLAVEISNOTBUSY_ID;
		//starting the counters for time events
		//start activity of WaitSlaveIsNotBusy by calling setFlag
		setFlag(WAITSLAVEISNOTBUSY_ID, statemachine::TF_DO_ACTIVITY, true);
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == GO_WAIT_POSITION_ID && (currentEvent->associatedState == GO_WAIT_POSITION_ID)) {
		//from go_wait_position to Rewind
		if (true) {
		states[PRINCIPALSTATE_ID].actives[0] = REWIND_ID;
		//starting the counters for time events
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == SENDDELIVERCOMMAND_ID && (currentEvent->associatedState == SENDDELIVERCOMMAND_ID)) {
		//from SendDeliverCommand to WaitSlaveIsNotBusy2
		if (true) {
		states[PRINCIPALSTATE_ID].actives[0] = WAITSLAVEISNOTBUSY2_ID;
		//starting the counters for time events
		//start activity of WaitSlaveIsNotBusy2 by calling setFlag
		setFlag(WAITSLAVEISNOTBUSY2_ID, statemachine::TF_DO_ACTIVITY, true);
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == GO_CHECK_PRESENCE_POSITION_ID && (currentEvent->associatedState == GO_CHECK_PRESENCE_POSITION_ID)) {
		//from go_check_presence_position to choice2
		if (true) {
			if (choice2_CompletionEvent == 0) {
				states[PRINCIPALSTATE_ID].actives[0] = MISPLACE_ID;
				//starting the counters for time events
				//start activity of Misplace by calling setFlag
				setFlag(MISPLACE_ID, statemachine::TF_DO_ACTIVITY, true);
			} else { 
				states[PRINCIPALSTATE_ID].actives[0] = DELIVER_CAR_ID;
				//starting the counters for time events
				//start activity of Deliver_car by calling setFlag
				setFlag(DELIVER_CAR_ID, statemachine::TF_DO_ACTIVITY, true);
			}
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == SENDENDOFMODULEEVENT_ID && (currentEvent->associatedState == SENDENDOFMODULEEVENT_ID)) {
		//from SendEndOfModuleEvent to go_stop_position
		if (true) {
		states[PRINCIPALSTATE_ID].actives[0] = GO_STOP_POSITION_ID;
		//starting the counters for time events
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == WAITSLAVEISNOTBUSY_ID && (currentEvent->associatedState == WAITSLAVEISNOTBUSY_ID)) {
		//from WaitSlaveIsNotBusy to choice3
		if (true) {
			if (choice3_CompletionEvent == 0) {
				states[PRINCIPALSTATE_ID].actives[0] = GO_WAIT_POSITION_ID;
				//starting the counters for time events
				//start activity of go_wait_position by calling setFlag
				setFlag(GO_WAIT_POSITION_ID, statemachine::TF_DO_ACTIVITY, true);
			} else { 
				PrincipalState_Region1_Exit();
				activeStateID = RESTART_ID;
				//starting the counters for time events
			}
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[PRINCIPALSTATE_ID].actives[0] == WAITSLAVEISNOTBUSY2_ID && (currentEvent->associatedState == WAITSLAVEISNOTBUSY2_ID)) {
		//from WaitSlaveIsNotBusy2 to choice
		if (true) {
			if (choice_CompletionEvent == 0) {
				states[PRINCIPALSTATE_ID].actives[0] = SENDENDOFMODULEEVENT_ID;
				//starting the counters for time events
				//start activity of SendEndOfModuleEvent by calling setFlag
				setFlag(SENDENDOFMODULEEVENT_ID, statemachine::TF_DO_ACTIVITY, true);
			} else if (choice_CompletionEvent == 1) {
				states[PRINCIPALSTATE_ID].actives[0] = MISPLACE_ID;
				//starting the counters for time events
				//start activity of Misplace by calling setFlag
				setFlag(MISPLACE_ID, statemachine::TF_DO_ACTIVITY, true);
			} else { 
				PrincipalState_Region1_Exit();
				component->effectFromChoicetoRestart();
				activeStateID = RESTART_ID;
				//starting the counters for time events
			}
		systemState = statemachine::EVENT_CONSUMED;
		}
	}
}

/**
 * 
 * @param id 
 */
void ChassisConvoyer__Delegatee::StateEntry(unsigned int /*in*/ id) {
	switch(id) {
		default:
			//do nothing
			break;
	}
}

/**
 * 
 * @param id 
 */
void ChassisConvoyer__Delegatee::StateExit(unsigned int /*in*/ id) {
	switch(id) {
		default:
			//do nothing
			break;
	}
}

/**
 * 
 * @param id 
 */
void ChassisConvoyer__Delegatee::StateDoActivity(unsigned int /*in*/ id) {
	switch(id) {
		default:
			//do nothing
			break;
	}
}

/**
 * 
 * @param data 
 * @return ret 
 */
 void* ChassisConvoyer__Delegatee::thread_func_wrapper(void* /*in*/ data) {
	statemachine::StructForThread_t* cptr = (statemachine::StructForThread_t*)data;
	ChassisConvoyer__Delegatee* ptr = (ChassisConvoyer__Delegatee*) cptr->ptr;
	switch(cptr->func_type) {
			case statemachine::TF_STATE_MACHINE_TYPE:
				ptr->dispatchEvent();
				break;
	}
	return NULL;
}

/**
 * 
 * @param id 
 */
void ChassisConvoyer__Delegatee::doCallActivity(int /*in*/ id) {
	flags[id] = false;
	while(systemState != statemachine::STOPPED) {
		pthread_mutex_lock(&mutexes[id]);
		while(!flags[id] && systemState != statemachine::STOPPED) {
			pthread_cond_wait(&conds[id], &mutexes[id]);
		}
		if (systemState != statemachine::STOPPED) {
			StateDoActivity(id);
		}
		bool commitEvent = false;
		if (flags[id]) {
			commitEvent = true;
			flags[id] = false;
		}
		pthread_cond_signal(&conds[id]);
		pthread_mutex_unlock(&mutexes[id]);
		if (commitEvent && systemState != statemachine::STOPPED) {
			if(id == REPLACE_ID || id == GO_CHECK_PRESENCE_POSITION_ID || id == DELIVER_CAR_ID || id == SENDENDOFMODULEEVENT_ID || id == SENDLOADCARCOMMAND_ID || id == WAITSLAVEISNOTBUSY_ID || id == GO_WAIT_POSITION_ID || id == SENDDELIVERCOMMAND_ID || id == WAITSLAVEISNOTBUSY2_ID || id == MISPLACE_ID) {
				//processCompletionEvent();
				eventQueue.push(statemachine::PRIORITY_1, NULL, COMPLETIONEVENT_ID, statemachine::COMPLETION_EVENT, id);
			}
		}
	}
}

/**
 * 
 * @param id 
 * @param func_type 
 * @param value 
 */
void ChassisConvoyer__Delegatee::setFlag(int /*in*/ id, char /*in*/ func_type, bool /*in*/ value) {
	//value = true => start activity
	//value = false => stop activity
	if (func_type == statemachine::TF_DO_ACTIVITY) {
		//push completion event
			if (value) {
				if(id == REPLACE_ID || id == GO_CHECK_PRESENCE_POSITION_ID || id == DELIVER_CAR_ID || id == SENDENDOFMODULEEVENT_ID || id == SENDLOADCARCOMMAND_ID || id == WAITSLAVEISNOTBUSY_ID || id == GO_WAIT_POSITION_ID || id == SENDDELIVERCOMMAND_ID || id == WAITSLAVEISNOTBUSY2_ID || id == MISPLACE_ID) {
					eventQueue.push(statemachine::PRIORITY_1, NULL, COMPLETIONEVENT_ID, statemachine::COMPLETION_EVENT, id);
				}
				return;
			} 
	}
}

/**
 * 
 * @param comp 
 */
void ChassisConvoyer__Delegatee::setComponent(::LegoCarFactoryRefactoringForSync::LegoCarComponents::Modules::Chassis::ChassisConvoyer* /*in*/ comp) {
	this->component = comp;
	this->get_sensor();
	this->get_pMotor();
	this->get_pStopProcess();
	this->get_pRestart();
	this->get_pPrepare();
	this->get_pDelivered();
}

/**
 * 
 * @return ret 
 */
 IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* ChassisConvoyer__Delegatee::get_pStopProcess() {
	component->pStopProcess.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 IPush<LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop>* ChassisConvoyer__Delegatee::get_pRestart() {
	component->pRestart.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 IPush<LegoCarFactoryRefactoringForSync::signals::PrepareConveyor>* ChassisConvoyer__Delegatee::get_pPrepare() {
	component->pPrepare.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 IPush<CarFactoryLibrary::events::DeliveredCarConveyor>* ChassisConvoyer__Delegatee::get_pDelivered() {
	component->pDelivered.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 ::EV3PapyrusLibrary::IColorSensor* ChassisConvoyer__Delegatee::get_sensor() {
	component->sensor.providedIntf = &(component->color_sensor);
	return component->sensor.providedIntf;
}

/**
 * 
 * @return ret 
 */
 ::EV3PapyrusLibrary::Interfaces::Actuators::ILargeMotor* ChassisConvoyer__Delegatee::get_pMotor() {
	component->pMotor.providedIntf = &(component->motor);
	return component->pMotor.providedIntf;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pStopProcess(IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* /*in*/ ref) {
	component->pStopProcess.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pCheckRack(IPush<CarFactoryLibrary::events::CheckRack>* /*in*/ ref) {
	component->pCheckRack.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pErrDetect(IPush<CarFactoryLibrary::events::ErrorDetection>* /*in*/ ref) {
	component->pErrDetect.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pEndOfMo_Control(IPush<CarFactoryLibrary::events::EndOfModule>* /*in*/ ref) {
	component->pEndOfMo_Control.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pEndOfMo_Shelf(IPush<CarFactoryLibrary::events::EndOfModule>* /*in*/ ref) {
	component->pEndOfMo_Shelf.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pEndOfMo_Robotic(IPush<CarFactoryLibrary::events::EndOfModule>* /*in*/ ref) {
	component->pEndOfMo_Robotic.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pLCD(::EV3PapyrusLibrary::Interfaces::EV3Brick::ILcd* /*in*/ ref) {
	component->pLCD.requiredIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisConvoyer__Delegatee::connect_pModule(::CarFactoryLibrary::IModule* /*in*/ ref) {
	component->pModule.requiredIntf = ref;
}



} // of namespace Chassis
} // of namespace __Architecture__Delegatee
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
              End of ChassisConvoyer__Delegatee class body
 ************************************************************/
