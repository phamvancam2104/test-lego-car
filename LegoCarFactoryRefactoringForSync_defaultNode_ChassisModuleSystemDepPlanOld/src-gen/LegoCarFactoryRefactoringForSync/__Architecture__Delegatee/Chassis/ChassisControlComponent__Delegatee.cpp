// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync___Architecture__Delegatee_Chassis_ChassisControlComponent__Delegatee_BODY

/************************************************************
              ChassisControlComponent__Delegatee class body
 ************************************************************/


// include associated header file
#include "LegoCarFactoryRefactoringForSync/__Architecture__Delegatee/Chassis/ChassisControlComponent__Delegatee.h"

// Derived includes directives
#include "CarFactoryLibrary/IModule.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "EV3PapyrusLibrary/Interfaces/EV3Brick/ILcd.h"
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Chassis/ChassisControlComponent.h"
#include "LegoCarFactoryRefactoringForSync/signals/PrepareConveyor.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"
#include "statemachine/Pkg_statemachine.h"


namespace LegoCarFactoryRefactoringForSync {
namespace __Architecture__Delegatee {
namespace Chassis {

// static attributes (if any)

/**
 * 
 */
void ChassisControlComponent__Delegatee::dispatchEvent() {
	bool popDeferred = false;
	dispatchFlag = true;
	
	//initialze root active state
	//execute initial effect
	ChassisControlStateMachine_Region1_Enter(CHASSISCONTROLCOMPONENT_CHASSISCONTROLSTATEMACHINE_REGION1_DEFAULT);
	
	while(systemState != statemachine::STOPPED) {
		//run-to-completion: need to have a mutex here
		currentEvent = eventQueue.pop(popDeferred);
		if (currentEvent != NULL) {
			CHASSISCONTROLCOMPONENT__DELEGATEE_GET_CONTROL
			switch(currentEvent->eventID) {
				case TE_50_MS__ID:
					processTE_50_ms_();
					break;
				case ENDOFMODULE_ID:
					::CarFactoryLibrary::events::EndOfModule sig_ENDOFMODULE_ID;
					memcpy(&sig_ENDOFMODULE_ID, currentEvent->data, sizeof(::CarFactoryLibrary::events::EndOfModule));
					processEndOfModule(sig_ENDOFMODULE_ID);
					break;
				case STOPPROCESS_ID:
					::LegoCarFactoryRefactoringForSync::signals::StopProcess sig_STOPPROCESS_ID;
					memcpy(&sig_STOPPROCESS_ID, currentEvent->data, sizeof(::LegoCarFactoryRefactoringForSync::signals::StopProcess));
					processStopProcess(sig_STOPPROCESS_ID);
					break;
				case ERRORDETECTION_ID:
					::CarFactoryLibrary::events::ErrorDetection sig_ERRORDETECTION_ID;
					memcpy(&sig_ERRORDETECTION_ID, currentEvent->data, sizeof(::CarFactoryLibrary::events::ErrorDetection));
					processErrorDetection(sig_ERRORDETECTION_ID);
					break;
					case COMPLETIONEVENT_ID: 
						processCompletionEvent();
					break;
			}
			if (systemState == statemachine::EVENT_DEFERRED) {
				eventQueue.saveDeferred(*currentEvent);
			}
			popDeferred = (systemState != statemachine::EVENT_DEFERRED);
			systemState = statemachine::IDLE;
			CHASSISCONTROLCOMPONENT__DELEGATEE_RELEASE_CONTROL
		}
	}
}

/**
 * 
 * @param enter_mode 
 */
void ChassisControlComponent__Delegatee::ChassisControlStateMachine_Region1_Enter(char /*in*/ enter_mode) {
	switch(enter_mode) {
		case CHASSISCONTROLCOMPONENT_CHASSISCONTROLSTATEMACHINE_REGION1_DEFAULT:
			activeStateID = INITIALIZATION_ID;
			
			
			//start activity of Initialization by calling setFlag
			setFlag(INITIALIZATION_ID, statemachine::TF_DO_ACTIVITY, true);
			//TODO: set systemState to EVENT_CONSUMED
			break;
	}
}

/**
 * 
 * @param enter_mode 
 */
void ChassisControlComponent__Delegatee::EmergencyStopState_Region1_Enter(char /*in*/ enter_mode) {
	switch(enter_mode) {
		case CHASSISCONTROLCOMPONENT_EMERGENCYSTOPSTATE_REGION1_DEFAULT:
			states[EMERGENCYSTOPSTATE_ID].actives[0] = CHECKSTATE_ID;
			
			
			//start activity of CheckState by calling setFlag
			setFlag(CHECKSTATE_ID, statemachine::TF_DO_ACTIVITY, true);
			//TODO: set systemState to EVENT_CONSUMED
			break;
	}
}

/**
 * 
 */
void ChassisControlComponent__Delegatee::EmergencyStopState_Region1_Exit() {
	//exiting region Region1
	if (states[EMERGENCYSTOPSTATE_ID].actives[0] != STATE_MAX) {
		//signal to exit the doActivity of sub-state of EmergencyStopState
		setFlag(states[EMERGENCYSTOPSTATE_ID].actives[0], statemachine::TF_DO_ACTIVITY, false);
		if (CHECKSTATE_ID == states[EMERGENCYSTOPSTATE_ID].actives[0]) {
		} else 
		if (STOPMOTORS_ID == states[EMERGENCYSTOPSTATE_ID].actives[0]) {
		}
		//exit action of sub-state of EmergencyStopState
		StateExit(states[EMERGENCYSTOPSTATE_ID].actives[0]);
		//set active sub-state of EmergencyStopState to STATE_MAX meaning NULL
		states[EMERGENCYSTOPSTATE_ID].actives[0] = STATE_MAX;
	}
}

/**
 * 
 */
ChassisControlComponent__Delegatee::ChassisControlComponent__Delegatee(): systemState(statemachine::IDLE) {
	//startBehavior();
}

/**
 * 
 */
void ChassisControlComponent__Delegatee::startBehavior() {
	// initialize all threads, the threads wait until the associated flag is set
	for(int i = 0; i < (int) STATE_MAX; i++) {
		if (states[i].hasDoActivity) {
			threadStructs[i].id = i;
			threadStructs[i].ptr = this;
			threadStructs[i].func_type = statemachine::TF_DO_ACTIVITY;
			mutexes[i] = PTHREAD_MUTEX_INITIALIZER;
			conds[i] = PTHREAD_COND_INITIALIZER;
			pthread_create(&threads[i], NULL, &ChassisControlComponent__Delegatee::thread_func_wrapper, &threadStructs[i]);
		}
	}
		
	timeEventThreadStructs[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(TE_50_MS__ID)].duration = 50;
	for(int i = CHASSISCONTROLCOMPONENT__DELEGATEE_TIME_EVENT_LOWER_BOUND; i < 1; i++) {
		timeEventThreadStructs[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)].id = i;
		timeEventThreadStructs[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)].ptr = this;
		timeEventThreadStructs[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)].func_type = statemachine::TF_TIME_EVENT;
		timeEventMutexes[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)] = PTHREAD_MUTEX_INITIALIZER;
		timeEventConds[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)] = PTHREAD_COND_INITIALIZER;
		pthread_create(&timeEventThreads[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)], NULL, &ChassisControlComponent__Delegatee::thread_func_wrapper, &timeEventThreadStructs[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)]);
		while(timeEventFlags[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)]) {}
	}
			
			
	
	runToCompletionMutex = PTHREAD_MUTEX_INITIALIZER;
	runToCompletionCond = PTHREAD_COND_INITIALIZER;
	
	dispatchStruct = statemachine::StructForThread_t(this, 0, 0, statemachine::TF_STATE_MACHINE_TYPE, 0);
	ChassisControlComponent__Delegatee_THREAD_CREATE(dispatchThread, dispatchStruct)
}

/**
 * 
 */
ChassisControlComponent__Delegatee::~ChassisControlComponent__Delegatee() {
	stopBehavior();
}

/**
 * 
 */
void ChassisControlComponent__Delegatee::stopBehavior() {
	systemState = statemachine::STOPPED;
		//signal and wait for doActivity termination
		for(int i = 0; i < (int) STATE_MAX; i++) {
			if (states[i].hasDoActivity) {
				pthread_cond_signal(&conds[i]);
				pthread_join(threads[i], NULL);
			}
		}
		
		//signal and wait for time event thread termination
		for(int i = CHASSISCONTROLCOMPONENT__DELEGATEE_TIME_EVENT_LOWER_BOUND; i < 1; i++) {
			pthread_cond_signal(&timeEventConds[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)]);
			pthread_join(timeEventThreads[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(i)], NULL);
		}	
	
		//main thread
		pthread_join(dispatchThread, NULL);
}

/**
 * 
 */
void ChassisControlComponent__Delegatee::processTE_50_ms_() {
	systemState = statemachine::EVENT_PROCESSING;
}

/**
 * 
 * @param sig 
 */
void ChassisControlComponent__Delegatee::processEndOfModule(::CarFactoryLibrary::events::EndOfModule& /*in*/ sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch(activeStateID) {
			case EMERGENCYSTOPSTATE_ID: 
				//from EmergencyStopState to choice2
				if (true) {
					EmergencyStopState_Region1_Exit();
					if (choice2_CompletionEvent == 1) {
						component->fromChoice2toPrepareConvoyerEffect();
						activeStateID = PREPARECONVEYOR_ID;
						//starting the counters for time events
						//start activity of PrepareConveyor by calling setFlag
						setFlag(PREPARECONVEYOR_ID, statemachine::TF_DO_ACTIVITY, true);
					} else { 
						component->rewind_last_module();
						activeStateID = SENDSTOPMESSAGE_ID;
						//starting the counters for time events
						//start activity of SendStopMessage by calling setFlag
						setFlag(SENDSTOPMESSAGE_ID, statemachine::TF_DO_ACTIVITY, true);
					}
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			default:
				//do nothing
				break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisControlComponent__Delegatee::push(::CarFactoryLibrary::events::EndOfModule& /*in*/ sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, ENDOFMODULE_ID, statemachine::SIGNAL_EVENT, 0, sizeof(::CarFactoryLibrary::events::EndOfModule));
}

/**
 * 
 * @param sig 
 */
void ChassisControlComponent__Delegatee::processStopProcess(::LegoCarFactoryRefactoringForSync::signals::StopProcess& /*in*/ sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch(activeStateID) {
			case EMERGENCYSTOPSTATE_ID: 
				//from EmergencyStopState to EmergencyButtonPressState
				if (true) {
				EmergencyStopState_Region1_Exit();
				activeStateID = EMERGENCYBUTTONPRESSSTATE_ID;
				//starting the counters for time events
				//start activity of EmergencyButtonPressState by calling setFlag
				setFlag(EMERGENCYBUTTONPRESSSTATE_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			default:
				//do nothing
				break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisControlComponent__Delegatee::push(::LegoCarFactoryRefactoringForSync::signals::StopProcess& /*in*/ sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, STOPPROCESS_ID, statemachine::SIGNAL_EVENT, 0, sizeof(::LegoCarFactoryRefactoringForSync::signals::StopProcess));
}

/**
 * 
 * @param sig 
 */
void ChassisControlComponent__Delegatee::processErrorDetection(::CarFactoryLibrary::events::ErrorDetection& /*in*/ sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch(activeStateID) {
			case EMERGENCYSTOPSTATE_ID: 
				//from EmergencyStopState to Misplace
				if (true) {
				EmergencyStopState_Region1_Exit();
				component->effectFromEmergencyStopStatetoMisplace(sig);
				activeStateID = MISPLACE_ID;
				//starting the counters for time events
				//start activity of Misplace by calling setFlag
				setFlag(MISPLACE_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			default:
				//do nothing
				break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisControlComponent__Delegatee::push(::CarFactoryLibrary::events::ErrorDetection& /*in*/ sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, ERRORDETECTION_ID, statemachine::SIGNAL_EVENT, 0, sizeof(::CarFactoryLibrary::events::ErrorDetection));
}

/**
 * 
 */
void ChassisControlComponent__Delegatee::processCompletionEvent() {
	systemState = statemachine::EVENT_PROCESSING;
	if (states[EMERGENCYSTOPSTATE_ID].actives[0] == STOPMOTORS_ID && (currentEvent->associatedState == STOPMOTORS_ID)) {
		//from StopMotors to EmergencyButtonPressState
		if (true) {
		EmergencyStopState_Region1_Exit();
		activeStateID = EMERGENCYBUTTONPRESSSTATE_ID;
		//starting the counters for time events
		//start activity of EmergencyButtonPressState by calling setFlag
		setFlag(EMERGENCYBUTTONPRESSSTATE_ID, statemachine::TF_DO_ACTIVITY, true);
		systemState = statemachine::EVENT_CONSUMED;
		}
	} else 
	if (states[EMERGENCYSTOPSTATE_ID].actives[0] == CHECKSTATE_ID && (currentEvent->associatedState == CHECKSTATE_ID)) {
		//from CheckState to choice1
		if (true) {
			if (component->fromChoice1toStopMotorsGuard()) {
				states[EMERGENCYSTOPSTATE_ID].actives[0] = STOPMOTORS_ID;
				//starting the counters for time events
				//start activity of StopMotors by calling setFlag
				setFlag(STOPMOTORS_ID, statemachine::TF_DO_ACTIVITY, true);
			} else { 
				states[EMERGENCYSTOPSTATE_ID].actives[0] = CHECKSTATE_ID;
				//starting the counters for time events
				//start activity of CheckState by calling setFlag
				setFlag(CHECKSTATE_ID, statemachine::TF_DO_ACTIVITY, true);
			}
		systemState = statemachine::EVENT_CONSUMED;
		}
	}
	if (systemState == statemachine::EVENT_PROCESSING && (currentEvent->associatedState == activeStateID)) {
		switch(activeStateID) {
			case MISPLACE_ID: 
				//from Misplace to choice0
				if (true) {
					if (choice0_CompletionEvent == 0) {
						component->choice0toSendRestartEventEffect();
						activeStateID = SENDRESTARTEVENT_ID;
						//starting the counters for time events
						//start activity of SendRestartEvent by calling setFlag
						setFlag(SENDRESTARTEVENT_ID, statemachine::TF_DO_ACTIVITY, true);
					} else { 
						if (choice_CompletionEvent == 1) {
							activeStateID = SENDRESTARTEVENT_ID;
							//starting the counters for time events
							//start activity of SendRestartEvent by calling setFlag
							setFlag(SENDRESTARTEVENT_ID, statemachine::TF_DO_ACTIVITY, true);
						} else { 
							activeStateID = MISPLACE_ID;
							//starting the counters for time events
							//start activity of Misplace by calling setFlag
							setFlag(MISPLACE_ID, statemachine::TF_DO_ACTIVITY, true);
						}
					}
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case EMERGENCYBUTTONPRESSSTATE_ID: 
				//from EmergencyButtonPressState to EmergencyStopDisplay
				if (true) {
				activeStateID = EMERGENCYSTOPDISPLAY_ID;
				//starting the counters for time events
				//start activity of EmergencyStopDisplay by calling setFlag
				setFlag(EMERGENCYSTOPDISPLAY_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case INITIALIZATION_ID: 
				//from Initialization to choice13
				if (true) {
					if (choice13_CompletionEvent == 0) {
						activeStateID = CHOOSEBACKFRONTORDER_ID;
						//starting the counters for time events
						//start activity of ChooseBackFrontOrder by calling setFlag
						setFlag(CHOOSEBACKFRONTORDER_ID, statemachine::TF_DO_ACTIVITY, true);
					} else { 
						activeStateID = STATE_MAX;
					}
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case SENDRESTARTEVENT_ID: 
				//from SendRestartEvent to PrepareConveyor
				if (true) {
				activeStateID = PREPARECONVEYOR_ID;
				//starting the counters for time events
				//start activity of PrepareConveyor by calling setFlag
				setFlag(PREPARECONVEYOR_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case PREPARECONVEYOR_ID: 
				//from PrepareConveyor to EmergencyStopState
				if (true) {
				activeStateID = EMERGENCYSTOPSTATE_ID;
				//starting the counters for time events
				EmergencyStopState_Region1_Enter(CHASSISCONTROLCOMPONENT_EMERGENCYSTOPSTATE_REGION1_DEFAULT);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case EMERGENCYSTOPDISPLAY_ID: 
				//from EmergencyStopDisplay to choice5
				if (true) {
					if (choice5_CompletionEvent == 1) {
						activeStateID = SENDRESTARTEVENT_ID;
						//starting the counters for time events
						//start activity of SendRestartEvent by calling setFlag
						setFlag(SENDRESTARTEVENT_ID, statemachine::TF_DO_ACTIVITY, true);
					} else { 
						if (choice4_CompletionEvent == 0) {
							activeStateID = SENDRESTARTEVENT_ID;
							//starting the counters for time events
							//start activity of SendRestartEvent by calling setFlag
							setFlag(SENDRESTARTEVENT_ID, statemachine::TF_DO_ACTIVITY, true);
						} else { 
							activeStateID = EMERGENCYSTOPDISPLAY_ID;
							//starting the counters for time events
							//start activity of EmergencyStopDisplay by calling setFlag
							setFlag(EMERGENCYSTOPDISPLAY_ID, statemachine::TF_DO_ACTIVITY, true);
						}
					}
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case PLACEORDER_ID: 
				//from PlaceOrder to PrepareConveyor
				if (true) {
				activeStateID = PREPARECONVEYOR_ID;
				//starting the counters for time events
				//start activity of PrepareConveyor by calling setFlag
				setFlag(PREPARECONVEYOR_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case SENDSTOPMESSAGE_ID: 
				//from SendStopMessage to FinalState2
				if (true) {
				activeStateID = STATE_MAX;
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			case CHOOSEBACKFRONTORDER_ID: 
				//from ChooseBackFrontOrder to PlaceOrder
				if (true) {
				activeStateID = PLACEORDER_ID;
				//starting the counters for time events
				//start activity of PlaceOrder by calling setFlag
				setFlag(PLACEORDER_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
				}
				break;
			default:
				//do nothing
				break;
		}
	}
}

/**
 * 
 * @param id 
 */
void ChassisControlComponent__Delegatee::StateEntry(unsigned int /*in*/ id) {
	switch(id) {
		default:
			//do nothing
			break;
	}
}

/**
 * 
 * @param id 
 */
void ChassisControlComponent__Delegatee::StateExit(unsigned int /*in*/ id) {
	switch(id) {
		default:
			//do nothing
			break;
	}
}

/**
 * 
 * @param id 
 */
void ChassisControlComponent__Delegatee::StateDoActivity(unsigned int /*in*/ id) {
	switch(id) {
		default:
			//do nothing
			break;
	}
}

/**
 * 
 * @param data 
 * @return ret 
 */
 void* ChassisControlComponent__Delegatee::thread_func_wrapper(void* /*in*/ data) {
	statemachine::StructForThread_t* cptr = (statemachine::StructForThread_t*)data;
	ChassisControlComponent__Delegatee* ptr = (ChassisControlComponent__Delegatee*) cptr->ptr;
	switch(cptr->func_type) {
		case statemachine::TF_TIME_EVENT:
			ptr->listenTimeEvent(cptr->id, cptr->duration);
			break;
			case statemachine::TF_STATE_MACHINE_TYPE:
				ptr->dispatchEvent();
				break;
	}
	return NULL;
}

/**
 * 
 * @param id 
 */
void ChassisControlComponent__Delegatee::doCallActivity(int /*in*/ id) {
	flags[id] = false;
	while(systemState != statemachine::STOPPED) {
		pthread_mutex_lock(&mutexes[id]);
		while(!flags[id] && systemState != statemachine::STOPPED) {
			pthread_cond_wait(&conds[id], &mutexes[id]);
		}
		if (systemState != statemachine::STOPPED) {
			StateDoActivity(id);
		}
		bool commitEvent = false;
		if (flags[id]) {
			commitEvent = true;
			flags[id] = false;
		}
		pthread_cond_signal(&conds[id]);
		pthread_mutex_unlock(&mutexes[id]);
		if (commitEvent && systemState != statemachine::STOPPED) {
			if(id == INITIALIZATION_ID || id == MISPLACE_ID || id == CHECKSTATE_ID || id == STOPMOTORS_ID || id == EMERGENCYBUTTONPRESSSTATE_ID || id == EMERGENCYSTOPDISPLAY_ID || id == SENDRESTARTEVENT_ID || id == PREPARECONVEYOR_ID || id == PLACEORDER_ID || id == SENDSTOPMESSAGE_ID || id == CHOOSEBACKFRONTORDER_ID) {
				//processCompletionEvent();
				eventQueue.push(statemachine::PRIORITY_1, NULL, COMPLETIONEVENT_ID, statemachine::COMPLETION_EVENT, id);
			}
		}
	}
}

/**
 * 
 * @param id 
 * @param func_type 
 * @param value 
 */
void ChassisControlComponent__Delegatee::setFlag(int /*in*/ id, char /*in*/ func_type, bool /*in*/ value) {
	//value = true => start activity
	//value = false => stop activity
	if (func_type == statemachine::TF_TIME_EVENT) {
		pthread_mutex_lock(&timeEventMutexes[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)]);
		timeEventFlags[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)] = value;
		pthread_cond_signal(&timeEventConds[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)]);
		pthread_mutex_unlock(&timeEventMutexes[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)]);
		return;
	}
	if (func_type == statemachine::TF_DO_ACTIVITY) {
		//push completion event
			if (value) {
				if(id == INITIALIZATION_ID || id == MISPLACE_ID || id == CHECKSTATE_ID || id == STOPMOTORS_ID || id == EMERGENCYBUTTONPRESSSTATE_ID || id == EMERGENCYSTOPDISPLAY_ID || id == SENDRESTARTEVENT_ID || id == PREPARECONVEYOR_ID || id == PLACEORDER_ID || id == SENDSTOPMESSAGE_ID || id == CHOOSEBACKFRONTORDER_ID) {
					eventQueue.push(statemachine::PRIORITY_1, NULL, COMPLETIONEVENT_ID, statemachine::COMPLETION_EVENT, id);
				}
				return;
			} 
	}
}

/**
 * 
 * @param id 
 * @param duration 
 */
void ChassisControlComponent__Delegatee::listenTimeEvent(int /*in*/ id, int /*in*/ duration) {
	struct timeval tv;
	struct timespec ts;
	int timedWaitResult = 0;
	while(systemState != statemachine::STOPPED) {
		pthread_mutex_lock(&timeEventMutexes[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)]);
		while(!timeEventFlags[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)] && systemState != statemachine::STOPPED) {
			pthread_cond_wait(&timeEventConds[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)], &timeEventMutexes[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)]);
		}
		
		gettimeofday(&tv, NULL);
		ts.tv_sec = time(NULL) + duration / 1000;
		ts.tv_nsec = tv.tv_usec * 1000 + 1000 * 1000 * (duration % 1000);
		ts.tv_sec += ts.tv_nsec / (1000 * 1000 * 1000);
		ts.tv_nsec %= (1000 * 1000 * 1000);
		if (systemState != statemachine::STOPPED) {
			timedWaitResult = pthread_cond_timedwait(&timeEventConds[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)], &timeEventMutexes[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)], &ts);
		}
	  	bool commitEvent = false;
	  	if (timedWaitResult != 0) {
	  		//timeout
	  		commitEvent = true;
	  	}
		timeEventFlags[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)] = false;
		pthread_cond_signal(&timeEventConds[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)]);
		pthread_mutex_unlock(&timeEventMutexes[CHASSISCONTROLCOMPONENT__DELEGATEE_TE_INDEX(id)]);
		if (commitEvent && systemState != statemachine::STOPPED) {
			//the state does not change, push time event to the queue
			eventQueue.push(statemachine::PRIORITY_2, NULL, id, statemachine::TIME_EVENT, id);
		}
	}
}

/**
 * 
 * @param comp 
 */
void ChassisControlComponent__Delegatee::setComponent(::LegoCarFactoryRefactoringForSync::LegoCarComponents::Modules::Chassis::ChassisControlComponent* /*in*/ comp) {
	this->component = comp;
	this->get_pLCD();
	this->get_pModule();
	this->get_pOutStopProcess_Shelf();
	this->get_pStopProcess_Convoyer();
	this->get_pErrDetect();
	this->get_pEndOfMo();
}

/**
 * 
 * @return ret 
 */
 IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* ChassisControlComponent__Delegatee::get_pOutStopProcess_Shelf() {
	component->pOutStopProcess_Shelf.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* ChassisControlComponent__Delegatee::get_pStopProcess_Convoyer() {
	component->pStopProcess_Convoyer.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 IPush<CarFactoryLibrary::events::ErrorDetection>* ChassisControlComponent__Delegatee::get_pErrDetect() {
	component->pErrDetect.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 IPush<CarFactoryLibrary::events::EndOfModule>* ChassisControlComponent__Delegatee::get_pEndOfMo() {
	component->pEndOfMo.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
 ::EV3PapyrusLibrary::Interfaces::EV3Brick::ILcd* ChassisControlComponent__Delegatee::get_pLCD() {
	component->pLCD.providedIntf = &(component->ev3Brick.lcdScreen);
	return component->pLCD.providedIntf;
}

/**
 * 
 * @return ret 
 */
 ::CarFactoryLibrary::IModule* ChassisControlComponent__Delegatee::get_pModule() {
	component->pModule.providedIntf = component;
	return component->pModule.providedIntf;
}

/**
 * 
 * @param ref 
 */
void ChassisControlComponent__Delegatee::connect_pOutStopProcess_Shelf(IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* /*in*/ ref) {
	component->pOutStopProcess_Shelf.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisControlComponent__Delegatee::connect_pOutStopProcess_RoboticArm(IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* /*in*/ ref) {
	component->pOutStopProcess_RoboticArm.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisControlComponent__Delegatee::connect_pOutRestart_Shelf(IPush<LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop>* /*in*/ ref) {
	component->pOutRestart_Shelf.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisControlComponent__Delegatee::connect_pOutRestart_Convoyer(IPush<LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop>* /*in*/ ref) {
	component->pOutRestart_Convoyer.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisControlComponent__Delegatee::connect_pPrepare(IPush<LegoCarFactoryRefactoringForSync::signals::PrepareConveyor>* /*in*/ ref) {
	component->pPrepare.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisControlComponent__Delegatee::connect_pOutRestart_Robotic(IPush<LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop>* /*in*/ ref) {
	component->pOutRestart_Robotic.outIntf = ref;
}



} // of namespace Chassis
} // of namespace __Architecture__Delegatee
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
              End of ChassisControlComponent__Delegatee class body
 ************************************************************/
