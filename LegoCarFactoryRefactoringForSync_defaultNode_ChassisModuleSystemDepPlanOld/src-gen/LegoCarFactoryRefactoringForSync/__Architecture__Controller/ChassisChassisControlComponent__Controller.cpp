// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define LegoCarFactoryRefactoringForSync___Architecture__Controller_ChassisChassisControlComponent__Controller_BODY

/************************************************************
 ChassisChassisControlComponent__Controller class body
 ************************************************************/

// include associated header file
#include "LegoCarFactoryRefactoringForSync/__Architecture__Controller/ChassisChassisControlComponent__Controller.h"

// Derived includes directives
#include "CarFactoryLibrary/IModule.h"
#include "CarFactoryLibrary/events/EndOfModule.h"
#include "CarFactoryLibrary/events/ErrorDetection.h"
#include "EV3PapyrusLibrary/Interfaces/EV3Brick/ILcd.h"
#include "LegoCarFactoryRefactoringForSync/LegoCarComponents/Modules/Chassis/ChassisControlComponent.h"
#include "LegoCarFactoryRefactoringForSync/signals/PrepareConveyor.h"
#include "LegoCarFactoryRefactoringForSync/signals/RestartAfterEmergencyStop.h"
#include "LegoCarFactoryRefactoringForSync/signals/StopProcess.h"
#include "statemachine/Pkg_statemachine.h"

namespace LegoCarFactoryRefactoringForSync {
namespace __Architecture__Controller {

// static attributes (if any)

/**
 * 
 */
void ChassisChassisControlComponent__Controller::dispatchEvent() {
	bool popDeferred = false;
	dispatchFlag = true;

	//initialze root active state
	//execute initial effect
	ChassisControlStateMachine_Region1_Enter (CHASSISCONTROLCOMPONENT_CHASSISCONTROLSTATEMACHINE_REGION1_DEFAULT);

	while (systemState != statemachine::STOPPED) {
		//run-to-completion: need to have a mutex here
		currentEvent = eventQueue.pop(popDeferred);
		if (currentEvent != NULL) {
			CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_GET_CONTROL
			switch (currentEvent->eventID) {
			case ERRORDETECTION_ID:
				::CarFactoryLibrary::events::ErrorDetection sig_ERRORDETECTION_ID;
				memcpy(&sig_ERRORDETECTION_ID, currentEvent->data,
						sizeof(::CarFactoryLibrary::events::ErrorDetection));
				processErrorDetection(sig_ERRORDETECTION_ID);
				break;
			case STOPPROCESS_ID:
				::LegoCarFactoryRefactoringForSync::signals::StopProcess sig_STOPPROCESS_ID;
				memcpy(&sig_STOPPROCESS_ID, currentEvent->data,
						sizeof(::LegoCarFactoryRefactoringForSync::signals::StopProcess));
				processStopProcess(sig_STOPPROCESS_ID);
				break;
			case ENDOFMODULE_ID:
				::CarFactoryLibrary::events::EndOfModule sig_ENDOFMODULE_ID;
				memcpy(&sig_ENDOFMODULE_ID, currentEvent->data,
						sizeof(::CarFactoryLibrary::events::EndOfModule));
				processEndOfModule(sig_ENDOFMODULE_ID);
				break;
			case TE_50_MS__ID:
				processTE_50_ms_();
				break;
			case COMPLETIONEVENT_ID:
				processCompletionEvent();
				break;
			}
			if (systemState == statemachine::EVENT_DEFERRED) {
				eventQueue.saveDeferred(*currentEvent);
			}
			popDeferred = (systemState != statemachine::EVENT_DEFERRED);
			systemState = statemachine::IDLE;
			CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_RELEASE_CONTROL
		}
	}
}

/**
 * 
 * @param enter_mode 
 */
void ChassisChassisControlComponent__Controller::ChassisControlStateMachine_Region1_Enter(
		char /*in*/enter_mode) {
	switch (enter_mode) {
	case CHASSISCONTROLCOMPONENT_CHASSISCONTROLSTATEMACHINE_REGION1_DEFAULT:
		activeStateID = INITIALIZATION_ID;

		//start activity of Initialization by calling setFlag
		setFlag(INITIALIZATION_ID, statemachine::TF_DO_ACTIVITY, true);
		//TODO: set systemState to EVENT_CONSUMED
		break;
	}
}

/**
 * 
 * @param enter_mode 
 */
void ChassisChassisControlComponent__Controller::EmergencyStopState_Region1_Enter(
		char /*in*/enter_mode) {
	switch (enter_mode) {
	case CHASSISCONTROLCOMPONENT_EMERGENCYSTOPSTATE_REGION1_DEFAULT:
		states[EMERGENCYSTOPSTATE_ID].actives[0] = CHECKSTATE_ID;

		//start activity of CheckState by calling setFlag
		setFlag(CHECKSTATE_ID, statemachine::TF_DO_ACTIVITY, true);
		//TODO: set systemState to EVENT_CONSUMED
		break;
	}
}

/**
 * 
 */
void ChassisChassisControlComponent__Controller::EmergencyStopState_Region1_Exit() {
	//exiting region Region1
	if (states[EMERGENCYSTOPSTATE_ID].actives[0] != STATE_MAX) {
		//signal to exit the doActivity of sub-state of EmergencyStopState
		setFlag(states[EMERGENCYSTOPSTATE_ID].actives[0],
				statemachine::TF_DO_ACTIVITY, false);
		if (CHECKSTATE_ID == states[EMERGENCYSTOPSTATE_ID].actives[0]) {
		} else if (STOPMOTORS_ID == states[EMERGENCYSTOPSTATE_ID].actives[0]) {
		}
		//exit action of sub-state of EmergencyStopState
		StateExit(states[EMERGENCYSTOPSTATE_ID].actives[0]);
		//set active sub-state of EmergencyStopState to STATE_MAX meaning NULL
		states[EMERGENCYSTOPSTATE_ID].actives[0] = STATE_MAX;
	}
}

/**
 * 
 * @param origin 
 */
ChassisChassisControlComponent__Controller::ChassisChassisControlComponent__Controller(
		::LegoCarFactoryRefactoringForSync::LegoCarComponents::Modules::Chassis::ChassisControlComponent* /*in*/origin) :
		eventQueue(50, eventArray), p_origin(origin) {
	//startBehavior();
}

/**
 * 
 */
void ChassisChassisControlComponent__Controller::startBehavior() {
	systemState = statemachine::IDLE;

	// initialize all threads, the threads wait until the associated flag is set
	for (int i = 0; i < (int) STATE_MAX; i++) {
		if (states[i].hasDoActivity) {
			threadStructs[i].id = i;
			threadStructs[i].ptr = this;
			threadStructs[i].func_type = statemachine::TF_DO_ACTIVITY;
			mutexes[i] = PTHREAD_MUTEX_INITIALIZER;
			conds[i] = PTHREAD_COND_INITIALIZER;
			pthread_create(&threads[i], NULL,
					&ChassisChassisControlComponent__Controller::thread_func_wrapper,
					&threadStructs[i]);
		}
	}

	timeEventThreadStructs[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
			TE_50_MS__ID)].duration = 50;
	for (int i =
			CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TIME_EVENT_LOWER_BOUND;
			i < 1; i++) {
		timeEventThreadStructs[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				i)].id = i;
		timeEventThreadStructs[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				i)].ptr = this;
		timeEventThreadStructs[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				i)].func_type = statemachine::TF_TIME_EVENT;
		timeEventMutexes[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(i)] =
				PTHREAD_MUTEX_INITIALIZER;
		timeEventConds[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(i)] =
				PTHREAD_COND_INITIALIZER;
		pthread_create(
				&timeEventThreads[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
						i)], NULL,
				&ChassisChassisControlComponent__Controller::thread_func_wrapper,
				&timeEventThreadStructs[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
						i)]);
		while (timeEventFlags[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				i)]) {
		}
	}

	runToCompletionMutex = PTHREAD_MUTEX_INITIALIZER;
	runToCompletionCond = PTHREAD_COND_INITIALIZER;

	dispatchStruct = statemachine::StructForThread_t(this, 0, 0,
			statemachine::TF_STATE_MACHINE_TYPE, 0);
	ChassisChassisControlComponent__Controller_THREAD_CREATE(dispatchThread,
			dispatchStruct)
}

/**
 * 
 */
ChassisChassisControlComponent__Controller::~ChassisChassisControlComponent__Controller() {
	stopBehavior();
}

/**
 * 
 */
void ChassisChassisControlComponent__Controller::stopBehavior() {
	systemState = statemachine::STOPPED;
	//signal and wait for doActivity termination
	for (int i = 0; i < (int) STATE_MAX; i++) {
		if (states[i].hasDoActivity) {
			pthread_cond_signal (&conds[i]);
			pthread_join(threads[i], NULL);
		}
	}

	//signal and wait for time event thread termination
	for (int i =
			CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TIME_EVENT_LOWER_BOUND;
			i < 1; i++) {
		pthread_cond_signal (&timeEventConds[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				i)]);
		pthread_join(
				timeEventThreads[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
						i)], NULL);
	}

	//main thread
	pthread_join(dispatchThread, NULL);

}

/**
 * 
 * @param sig 
 */
void ChassisChassisControlComponent__Controller::processErrorDetection(
		::CarFactoryLibrary::events::ErrorDetection& /*in*/sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch (activeStateID) {
		case EMERGENCYSTOPSTATE_ID:
			//from EmergencyStopState to Misplace
			if (true) {
				EmergencyStopState_Region1_Exit();
				p_origin->effectFromEmergencyStopStatetoMisplace(sig);
				activeStateID = MISPLACE_ID;
				//starting the counters for time events
				//start activity of Misplace by calling setFlag
				setFlag(MISPLACE_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		default:
			//do nothing
			break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisChassisControlComponent__Controller::push(
		::CarFactoryLibrary::events::ErrorDetection& /*in*/sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, ERRORDETECTION_ID,
			statemachine::SIGNAL_EVENT, 0,
			sizeof(::CarFactoryLibrary::events::ErrorDetection));
}

/**
 * 
 * @param sig 
 */
void ChassisChassisControlComponent__Controller::processStopProcess(
		::LegoCarFactoryRefactoringForSync::signals::StopProcess& /*in*/sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch (activeStateID) {
		case EMERGENCYSTOPSTATE_ID:
			//from EmergencyStopState to EmergencyButtonPressState
			if (true) {
				EmergencyStopState_Region1_Exit();
				activeStateID = EMERGENCYBUTTONPRESSSTATE_ID;
				//starting the counters for time events
				//start activity of EmergencyButtonPressState by calling setFlag
				setFlag(EMERGENCYBUTTONPRESSSTATE_ID,
						statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		default:
			//do nothing
			break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisChassisControlComponent__Controller::push(
		::LegoCarFactoryRefactoringForSync::signals::StopProcess& /*in*/sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, STOPPROCESS_ID,
			statemachine::SIGNAL_EVENT, 0,
			sizeof(::LegoCarFactoryRefactoringForSync::signals::StopProcess));
}

/**
 * 
 * @param sig 
 */
void ChassisChassisControlComponent__Controller::processEndOfModule(
		::CarFactoryLibrary::events::EndOfModule& /*in*/sig) {
	systemState = statemachine::EVENT_PROCESSING;
	if (systemState == statemachine::EVENT_PROCESSING) {
		switch (activeStateID) {
		case EMERGENCYSTOPSTATE_ID:
			//from EmergencyStopState to choice2
			if (true) {
				EmergencyStopState_Region1_Exit();
				if (p_origin->fromChoice2toPrepareConveyorGuard()) {
					activeStateID = PREPARECONVEYOR_ID;
					//starting the counters for time events
					//start activity of PrepareConveyor by calling setFlag
					setFlag(PREPARECONVEYOR_ID, statemachine::TF_DO_ACTIVITY,
							true);
				} else {
					activeStateID = SENDSTOPMESSAGE_ID;
					//starting the counters for time events
					//start activity of SendStopMessage by calling setFlag
					setFlag(SENDSTOPMESSAGE_ID, statemachine::TF_DO_ACTIVITY,
							true);
				}
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		default:
			//do nothing
			break;
		}
	}
}

/**
 * 
 * @param sig 
 */
void ChassisChassisControlComponent__Controller::push(
		::CarFactoryLibrary::events::EndOfModule& /*in*/sig) {
	eventQueue.push(statemachine::PRIORITY_2, &sig, ENDOFMODULE_ID,
			statemachine::SIGNAL_EVENT, 0,
			sizeof(::CarFactoryLibrary::events::EndOfModule));
}

/**
 * 
 */
void ChassisChassisControlComponent__Controller::processTE_50_ms_() {
	systemState = statemachine::EVENT_PROCESSING;
}

/**
 * 
 */
void ChassisChassisControlComponent__Controller::processCompletionEvent() {
	systemState = statemachine::EVENT_PROCESSING;
	if (states[EMERGENCYSTOPSTATE_ID].actives[0] == STOPMOTORS_ID
			&& (currentEvent->associatedState == STOPMOTORS_ID)) {
		//from StopMotors to EmergencyButtonPressState
		if (true) {
			EmergencyStopState_Region1_Exit();
			activeStateID = EMERGENCYBUTTONPRESSSTATE_ID;
			//starting the counters for time events
			//start activity of EmergencyButtonPressState by calling setFlag
			setFlag(EMERGENCYBUTTONPRESSSTATE_ID, statemachine::TF_DO_ACTIVITY,
					true);
			systemState = statemachine::EVENT_CONSUMED;
		}
	} else if (states[EMERGENCYSTOPSTATE_ID].actives[0] == CHECKSTATE_ID
			&& (currentEvent->associatedState == CHECKSTATE_ID)) {
		//from CheckState to choice1
		if (true) {
			if (p_origin->fromChoice1toStopMotorsGuard()) {
				states[EMERGENCYSTOPSTATE_ID].actives[0] = STOPMOTORS_ID;
				//starting the counters for time events
				//start activity of StopMotors by calling setFlag
				setFlag(STOPMOTORS_ID, statemachine::TF_DO_ACTIVITY, true);
			} else {
				states[EMERGENCYSTOPSTATE_ID].actives[0] = CHECKSTATE_ID;
				//starting the counters for time events
				//start activity of CheckState by calling setFlag
				setFlag(CHECKSTATE_ID, statemachine::TF_DO_ACTIVITY, true);
			}
			systemState = statemachine::EVENT_CONSUMED;
		}
	}
	if (systemState == statemachine::EVENT_PROCESSING
			&& (currentEvent->associatedState == activeStateID)) {
		switch (activeStateID) {
		case MISPLACE_ID:
			//from Misplace to choice0
			if (true) {
				if (p_origin->fromChoice0toSendRestartEventGuard()) {
					activeStateID = SENDRESTARTEVENT_ID;
					//starting the counters for time events
					//start activity of SendRestartEvent by calling setFlag
					setFlag(SENDRESTARTEVENT_ID, statemachine::TF_DO_ACTIVITY,
							true);
				} else {
					if (p_origin->fromChoicetoSendRestartEventGuard()) {
						activeStateID = SENDRESTARTEVENT_ID;
						//starting the counters for time events
						//start activity of SendRestartEvent by calling setFlag
						setFlag(SENDRESTARTEVENT_ID,
								statemachine::TF_DO_ACTIVITY, true);
					} else {
						activeStateID = MISPLACE_ID;
						//starting the counters for time events
						//start activity of Misplace by calling setFlag
						setFlag(MISPLACE_ID, statemachine::TF_DO_ACTIVITY,
								true);
					}
				}
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case EMERGENCYBUTTONPRESSSTATE_ID:
			//from EmergencyButtonPressState to EmergencyStopDisplay
			if (true) {
				activeStateID = EMERGENCYSTOPDISPLAY_ID;
				//starting the counters for time events
				//start activity of EmergencyStopDisplay by calling setFlag
				setFlag(EMERGENCYSTOPDISPLAY_ID, statemachine::TF_DO_ACTIVITY,
						true);
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case INITIALIZATION_ID:
			//from Initialization to choice13
			if (true) {
				if (p_origin->fromChoice13toChooseBackFrontOrderGuard()) {
					activeStateID = CHOOSEBACKFRONTORDER_ID;
					//starting the counters for time events
					//start activity of ChooseBackFrontOrder by calling setFlag
					setFlag(CHOOSEBACKFRONTORDER_ID,
							statemachine::TF_DO_ACTIVITY, true);
				} else {
					activeStateID = STATE_MAX;
				}
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case SENDRESTARTEVENT_ID:
			//from SendRestartEvent to PrepareConveyor
			if (true) {
				activeStateID = PREPARECONVEYOR_ID;
				//starting the counters for time events
				//start activity of PrepareConveyor by calling setFlag
				setFlag(PREPARECONVEYOR_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case PREPARECONVEYOR_ID:
			//from PrepareConveyor to EmergencyStopState
			if (true) {
				activeStateID = EMERGENCYSTOPSTATE_ID;
				//starting the counters for time events
				EmergencyStopState_Region1_Enter (CHASSISCONTROLCOMPONENT_EMERGENCYSTOPSTATE_REGION1_DEFAULT);
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case EMERGENCYSTOPDISPLAY_ID:
			//from EmergencyStopDisplay to choice5
			if (true) {
				if (p_origin->fromChoice5toSendRestartEventGuard()) {
					activeStateID = SENDRESTARTEVENT_ID;
					//starting the counters for time events
					//start activity of SendRestartEvent by calling setFlag
					setFlag(SENDRESTARTEVENT_ID, statemachine::TF_DO_ACTIVITY,
							true);
				} else {
					if (p_origin->fromChoice4toSendRestartEventGuard()) {
						activeStateID = SENDRESTARTEVENT_ID;
						//starting the counters for time events
						//start activity of SendRestartEvent by calling setFlag
						setFlag(SENDRESTARTEVENT_ID,
								statemachine::TF_DO_ACTIVITY, true);
					} else {
						activeStateID = EMERGENCYSTOPDISPLAY_ID;
						//starting the counters for time events
						//start activity of EmergencyStopDisplay by calling setFlag
						setFlag(EMERGENCYSTOPDISPLAY_ID,
								statemachine::TF_DO_ACTIVITY, true);
					}
				}
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case PLACEORDER_ID:
			//from PlaceOrder to PrepareConveyor
			if (true) {
				activeStateID = PREPARECONVEYOR_ID;
				//starting the counters for time events
				//start activity of PrepareConveyor by calling setFlag
				setFlag(PREPARECONVEYOR_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case SENDSTOPMESSAGE_ID:
			//from SendStopMessage to FinalState2
			if (true) {
				activeStateID = STATE_MAX;
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		case CHOOSEBACKFRONTORDER_ID:
			//from ChooseBackFrontOrder to PlaceOrder
			if (true) {
				activeStateID = PLACEORDER_ID;
				//starting the counters for time events
				//start activity of PlaceOrder by calling setFlag
				setFlag(PLACEORDER_ID, statemachine::TF_DO_ACTIVITY, true);
				systemState = statemachine::EVENT_CONSUMED;
			}
			break;
		default:
			//do nothing
			break;
		}
	}
}

/**
 * 
 * @param id 
 */
void ChassisChassisControlComponent__Controller::StateEntry(
		unsigned int /*in*/id) {
	switch (id) {
	default:
		//do nothing
		break;
	}
}

/**
 * 
 * @param id 
 */
void ChassisChassisControlComponent__Controller::StateExit(
		unsigned int /*in*/id) {
	switch (id) {
	default:
		//do nothing
		break;
	}
}

/**
 * 
 * @param id 
 */
void ChassisChassisControlComponent__Controller::StateDoActivity(
		unsigned int /*in*/id) {
	switch (id) {
	default:
		//do nothing
		break;
	}
}

/**
 * 
 * @param data 
 * @return ret 
 */
void* ChassisChassisControlComponent__Controller::thread_func_wrapper(
		void* /*in*/data) {
	statemachine::StructForThread_t* cptr =
			(statemachine::StructForThread_t*) data;
	ChassisChassisControlComponent__Controller* ptr =
			(ChassisChassisControlComponent__Controller*) cptr->ptr;
	switch (cptr->func_type) {
	case statemachine::TF_TIME_EVENT:
		ptr->listenTimeEvent(cptr->id, cptr->duration);
		break;
	case statemachine::TF_STATE_MACHINE_TYPE:
		ptr->dispatchEvent();
		break;
	}
	return NULL;
}

/**
 * 
 * @param id 
 */
void ChassisChassisControlComponent__Controller::doCallActivity(int /*in*/id) {
	flags[id] = false;
	while (systemState != statemachine::STOPPED) {
		pthread_mutex_lock (&mutexes[id]);
		while (!flags[id] && systemState != statemachine::STOPPED) {
			pthread_cond_wait(&conds[id], &mutexes[id]);
		}
		if (systemState != statemachine::STOPPED) {
			StateDoActivity(id);
		}
		bool commitEvent = false;
		if (flags[id]) {
			commitEvent = true;
			flags[id] = false;
		}
		pthread_cond_signal (&conds[id]);
		pthread_mutex_unlock(&mutexes[id]);
		if (commitEvent && systemState != statemachine::STOPPED) {
			if (id == INITIALIZATION_ID || id == MISPLACE_ID
					|| id == CHECKSTATE_ID || id == STOPMOTORS_ID
					|| id == EMERGENCYBUTTONPRESSSTATE_ID
					|| id == EMERGENCYSTOPDISPLAY_ID
					|| id == SENDRESTARTEVENT_ID || id == PREPARECONVEYOR_ID
					|| id == PLACEORDER_ID || id == SENDSTOPMESSAGE_ID
					|| id == CHOOSEBACKFRONTORDER_ID) {
				//processCompletionEvent();
				eventQueue.push(statemachine::PRIORITY_1, NULL,
						COMPLETIONEVENT_ID, statemachine::COMPLETION_EVENT, id);
			}
		}
	}
}

/**
 * 
 * @param id 
 * @param func_type 
 * @param value 
 */
void ChassisChassisControlComponent__Controller::setFlag(int /*in*/id,
		char /*in*/func_type, bool /*in*/value) {
	//value = true => start activity
	//value = false => stop activity
	if (func_type == statemachine::TF_TIME_EVENT) {
		pthread_mutex_lock (&timeEventMutexes[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				id)]);
		timeEventFlags[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(id)] =
				value;
		pthread_cond_signal (&timeEventConds[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				id)]);
		pthread_mutex_unlock(
				&timeEventMutexes[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
						id)]);
		return;
	}
	if (func_type == statemachine::TF_DO_ACTIVITY) {
		//push completion event
		if (value) {
			if (id == INITIALIZATION_ID || id == MISPLACE_ID
					|| id == CHECKSTATE_ID || id == STOPMOTORS_ID
					|| id == EMERGENCYBUTTONPRESSSTATE_ID
					|| id == EMERGENCYSTOPDISPLAY_ID
					|| id == SENDRESTARTEVENT_ID || id == PREPARECONVEYOR_ID
					|| id == PLACEORDER_ID || id == SENDSTOPMESSAGE_ID
					|| id == CHOOSEBACKFRONTORDER_ID) {
				eventQueue.push(statemachine::PRIORITY_1, NULL,
						COMPLETIONEVENT_ID, statemachine::COMPLETION_EVENT, id);
			}
			return;
		}
	}
}

/**
 * 
 * @param id 
 * @param duration 
 */
void ChassisChassisControlComponent__Controller::listenTimeEvent(int /*in*/id,
		int /*in*/duration) {
	struct timeval tv;
	struct timespec ts;
	int timedWaitResult = 0;
	while (systemState != statemachine::STOPPED) {
		pthread_mutex_lock (&timeEventMutexes[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				id)]);
		while (!timeEventFlags[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				id)] && systemState != statemachine::STOPPED) {
			pthread_cond_wait(
					&timeEventConds[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
							id)],
					&timeEventMutexes[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
							id)]);
		}

		gettimeofday(&tv, NULL);
		ts.tv_sec = time(NULL) + duration / 1000;
		ts.tv_nsec = tv.tv_usec * 1000 + 1000 * 1000 * (duration % 1000);
		ts.tv_sec += ts.tv_nsec / (1000 * 1000 * 1000);
		ts.tv_nsec %= (1000 * 1000 * 1000);
		if (systemState != statemachine::STOPPED) {
			timedWaitResult =
					pthread_cond_timedwait(
							&timeEventConds[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
									id)],
							&timeEventMutexes[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
									id)], &ts);
		}
		bool commitEvent = false;
		if (timedWaitResult != 0) {
			//timeout
			commitEvent = true;
		}
		timeEventFlags[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(id)] =
				false;
		pthread_cond_signal (&timeEventConds[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
				id)]);
		pthread_mutex_unlock(
				&timeEventMutexes[CHASSISCHASSISCONTROLCOMPONENT__CONTROLLER_TE_INDEX(
						id)]);
		if (commitEvent && systemState != statemachine::STOPPED) {
			//the state does not change, push time event to the queue
			eventQueue.push(statemachine::PRIORITY_2, NULL, id,
					statemachine::TIME_EVENT, id);
		}
	}
}

/**
 * 
 * @return ret 
 */
IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* ChassisChassisControlComponent__Controller::get_pStopProcess_Convoyer() {
	p_origin->pStopProcess_Convoyer.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
IPush<CarFactoryLibrary::events::ErrorDetection>* ChassisChassisControlComponent__Controller::get_pErrDetect() {
	p_origin->pErrDetect.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
IPush<CarFactoryLibrary::events::EndOfModule>* ChassisChassisControlComponent__Controller::get_pEndOfMo() {
	p_origin->pEndOfMo.inIntf = this;
	return this;
}

/**
 * 
 * @return ret 
 */
::EV3PapyrusLibrary::Interfaces::EV3Brick::ILcd* ChassisChassisControlComponent__Controller::get_pLCD() {
	p_origin->pLCD.providedIntf = &(p_origin->ev3Brick.lcdScreen);
	return p_origin->pLCD.providedIntf;
}

/**
 * 
 * @return ret 
 */
::CarFactoryLibrary::IModule* ChassisChassisControlComponent__Controller::get_pModule() {
	p_origin->pModule.providedIntf = this->p_origin;
	return p_origin->pModule.providedIntf;
}

/**
 * 
 * @param ref 
 */
void ChassisChassisControlComponent__Controller::connect_pOutStopProcess_Shelf(
		IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* /*in*/ref) {
	p_origin->pOutStopProcess_Shelf.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisChassisControlComponent__Controller::connect_pOutStopProcess_RoboticArm(
		IPush<LegoCarFactoryRefactoringForSync::signals::StopProcess>* /*in*/ref) {
	p_origin->pOutStopProcess_RoboticArm.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisChassisControlComponent__Controller::connect_pOutRestart_Shelf(
		IPush<
				LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop>* /*in*/ref) {
	p_origin->pOutRestart_Shelf.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisChassisControlComponent__Controller::connect_pOutRestart_Convoyer(
		IPush<
				LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop>* /*in*/ref) {
	p_origin->pOutRestart_Convoyer.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisChassisControlComponent__Controller::connect_pPrepare(
		IPush<LegoCarFactoryRefactoringForSync::signals::PrepareConveyor>* /*in*/ref) {
	p_origin->pPrepare.outIntf = ref;
}

/**
 * 
 * @param ref 
 */
void ChassisChassisControlComponent__Controller::connect_pOutRestart_Robotic(
		IPush<
				LegoCarFactoryRefactoringForSync::signals::RestartAfterEmergencyStop>* /*in*/ref) {
	p_origin->pOutRestart_Robotic.outIntf = ref;
}

} // of namespace __Architecture__Controller
} // of namespace LegoCarFactoryRefactoringForSync

/************************************************************
 End of ChassisChassisControlComponent__Controller class body
 ************************************************************/
